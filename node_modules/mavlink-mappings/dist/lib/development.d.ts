import { int16_t, int32_t, uint8_t, uint16_t, uint32_t, uint64_t, float } from './types';
import { MavLinkPacketRegistry, MavLinkPacketField, MavLinkData } from './mavlink';
import { LandingTargetType, MavLinkCommandRegistry } from './common';
/**
 * Airspeed sensor flags
 */
export declare enum AirspeedSensorFlags {
    /**
     * Airspeed sensor is unhealthy
     */
    'UNHEALTHY' = 1,
    /**
     * True if the data from this sensor is being actively used by the flight controller for guidance,
     * navigation or control.
     */
    'USING' = 2
}
/**
 * Battery status flags for fault, health and state indication.
 */
export declare enum MavBatteryStatusFlags {
    /**
     * The battery is not ready to use (fly). Set if the battery has faults or other conditions that make
     * it unsafe to fly with. Note: It will be the logical OR of other status bits (chosen by the
     * manufacturer/integrator).
     */
    'NOT_READY_TO_USE' = 1,
    /**
     * Battery is charging.
     */
    'CHARGING' = 2,
    /**
     * Battery is cell balancing (during charging). Not ready to use
     * (MAV_BATTERY_STATUS_FLAGS_NOT_READY_TO_USE may be set).
     */
    'CELL_BALANCING' = 4,
    /**
     * Battery cells are not balanced. Not ready to use.
     */
    'FAULT_CELL_IMBALANCE' = 8,
    /**
     * Battery is auto discharging (towards storage level). Not ready to use
     * (MAV_BATTERY_STATUS_FLAGS_NOT_READY_TO_USE would be set).
     */
    'AUTO_DISCHARGING' = 16,
    /**
     * Battery requires service (not safe to fly). This is set at vendor discretion. It is likely to be set
     * for most faults, and may also be set according to a maintenance schedule (such as age, or number of
     * recharge cycles, etc.).
     */
    'REQUIRES_SERVICE' = 32,
    /**
     * Battery is faulty and cannot be repaired (not safe to fly). This is set at vendor discretion. The
     * battery should be disposed of safely.
     */
    'BAD_BATTERY' = 64,
    /**
     * Automatic battery protection monitoring is enabled. When enabled, the system will monitor for
     * certain kinds of faults, such as cells being over-voltage. If a fault is triggered then and
     * protections are enabled then a safety fault (MAV_BATTERY_STATUS_FLAGS_FAULT_PROTECTION_SYSTEM) will
     * be set and power from the battery will be stopped. Note that battery protection monitoring should
     * only be enabled when the vehicle is landed. Once the vehicle is armed, or starts moving, the
     * protections should be disabled to prevent false positives from disabling the output.
     */
    'PROTECTIONS_ENABLED' = 128,
    /**
     * The battery fault protection system had detected a fault and cut all power from the battery. This
     * will only trigger if MAV_BATTERY_STATUS_FLAGS_PROTECTIONS_ENABLED is set. Other faults like
     * MAV_BATTERY_STATUS_FLAGS_FAULT_OVER_VOLT may also be set, indicating the cause of the protection
     * fault.
     */
    'FAULT_PROTECTION_SYSTEM' = 256,
    /**
     * One or more cells are above their maximum voltage rating.
     */
    'FAULT_OVER_VOLT' = 512,
    /**
     * One or more cells are below their minimum voltage rating. A battery that had deep-discharged might
     * be irrepairably damaged, and set both MAV_BATTERY_STATUS_FLAGS_FAULT_UNDER_VOLT and
     * MAV_BATTERY_STATUS_FLAGS_BAD_BATTERY.
     */
    'FAULT_UNDER_VOLT' = 1024,
    /**
     * Over-temperature fault.
     */
    'FAULT_OVER_TEMPERATURE' = 2048,
    /**
     * Under-temperature fault.
     */
    'FAULT_UNDER_TEMPERATURE' = 4096,
    /**
     * Over-current fault.
     */
    'FAULT_OVER_CURRENT' = 8192,
    /**
     * Short circuit event detected. The battery may or may not be safe to use (check other flags).
     */
    'FAULT_SHORT_CIRCUIT' = 16384,
    /**
     * Voltage not compatible with power rail voltage (batteries on same power rail should have similar
     * voltage).
     */
    'FAULT_INCOMPATIBLE_VOLTAGE' = 32768,
    /**
     * Battery firmware is not compatible with current autopilot firmware.
     */
    'FAULT_INCOMPATIBLE_FIRMWARE' = 65536,
    /**
     * Battery is not compatible due to cell configuration (e.g. 5s1p when vehicle requires 6s).
     */
    'FAULT_INCOMPATIBLE_CELLS_CONFIGURATION' = 131072,
    /**
     * Battery capacity_consumed and capacity_remaining values are relative to a full battery (they sum to
     * the total capacity of the battery). This flag would be set for a smart battery that can accurately
     * determine its remaining charge across vehicle reboots and discharge/recharge cycles. If unset the
     * capacity_consumed indicates the consumption since vehicle power-on, as measured using a power
     * monitor. The capacity_remaining, if provided, indicates the estimated remaining capacity on the
     * assumption that the battery was full on vehicle boot. If unset a GCS is recommended to advise that
     * users fully charge the battery on power on.
     */
    'CAPACITY_RELATIVE_TO_FULL' = 262144,
    /**
     * Reserved (not used). If set, this will indicate that an additional status field exists for higher
     * status values.
     */
    'EXTENDED' = 2147483648
}
/**
 * Commands to be executed by the MAV. They can be executed on user request, or as part of a mission
 * script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is
 * as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list
 * is similar what ARINC 424 is for commercial aircraft: A data format how to interpret
 * waypoint/mission data. NaN and INT32_MAX may be used in float/integer params (respectively) to
 * indicate optional/default values (e.g. to use the component's current yaw or latitude rather than a
 * specific value). See https://mavlink.io/en/guide/xml_schema.html#MAV_CMD for information about the
 * structure of the MAV_CMD entries
 */
export declare enum MavCmd {
    /**
     * Fly a figure eight path as defined by the parameters. Set parameters to NaN/INT32_MAX (as
     * appropriate) to use system-default values. The command is intended for fixed wing vehicles (and VTOL
     * hybrids flying in fixed-wing mode), allowing POI tracking for gimbals that don't support infinite
     * rotation. This command only defines the flight path. Speed should be set independently (use e.g.
     * MAV_CMD_DO_CHANGE_SPEED). Yaw and other degrees of freedom are not specified, and will be
     * flight-stack specific (on vehicles where they can be controlled independent of the heading).
     *
     * @note has location and is destination
     *
     * @param1 Major Radius[m] Major axis radius of the figure eight. Positive: orbit the north circle clockwise. Negative: orbit the north circle counter-clockwise.
          NaN: The radius will be set to 2.5 times the minor radius and direction is clockwise.
          Must be greater or equal to two times the minor radius for feasible values.
     * @param2 Minor Radius[m] Minor axis radius of the figure eight. Defines the radius of the two circles that make up the figure. Negative value has no effect.
          NaN: The radius will be set to the default loiter radius.
     * @param4 Orientation[rad] Orientation of the figure eight major axis with respect to true north (range: [-pi,pi]). NaN: use default orientation aligned to true north.
     * @param5 Latitude/X Center point latitude/X coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle position, or current center if already loitering.
     * @param6 Longitude/Y Center point longitude/Y coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle position, or current center if already loitering.
     * @param7 Altitude/Z Center point altitude MSL/Z coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle altitude.
     */
    'DO_FIGURE_EIGHT' = 35,
    /**
     * Request a target system to start an upgrade of one (or all) of its components. For example, the
     * command might be sent to a companion computer to cause it to upgrade a connected flight controller.
     * The system doing the upgrade will report progress using the normal command protocol sequence for a
     * long running operation. Command protocol information: https://mavlink.io/en/services/command.html.
     * @param1 Component ID Component id of the component to be upgraded. If set to 0, all components should be upgraded.
     * @param2 Reboot (min: 0, max: 1, increment: 1) 0: Do not reboot component after the action is executed, 1: Reboot component after the action is executed.
     * @param3 Reserved
     * @param4 Reserved
     * @param5 Reserved
     * @param6 Reserved
     * @param7 WIP: upgrade progress report rate (can be used for more granular control).
     */
    'DO_UPGRADE' = 247,
    /**
     * Command to test groups of related actuators together. This might include groups such as the
     * actuators that contribute to roll, pitch, or yaw torque, actuators that contribute to thrust in x,
     * y, z axis, tilt mechanisms, flaps and spoilers, and so on. This is similar to MAV_CMD_ACTUATOR_TEST,
     * except that multiple actuators may be affected. Different groups may also affect the same actuators
     * (as in the case of controls that affect torque in different axes). Autopilots must NACK this command
     * with MAV_RESULT_TEMPORARILY_REJECTED while armed.
     * @param1 Group Actuator group to check, such as actuators related to roll torque.
     * @param2 Value (min: -1, max: 1) Value to set. This is a normalized value across the full range of the tested group [-1,1].
     */
    'ACTUATOR_GROUP_TEST' = 309,
    /**
     * Set system and component id. This allows moving of a system and all its components to a new system
     * id, or moving a particular component to a new system/component id. Recipients must reject command
     * addressed to broadcast system ID.
     * @param1 System ID (min: 1, max: 255, increment: 1) New system ID for target component(s). 0: ignore and reject command (broadcast system ID not allowed).
     * @param2 Component ID (min: 0, max: 255, increment: 1) New component ID for target component(s). 0: ignore (component IDs don't change).
     * @param3 Reboot Reboot components after ID change. Any non-zero value triggers the reboot.
     */
    'DO_SET_SYS_CMP_ID' = 610,
    /**
     * Sets the GNSS coordinates of the vehicle local origin (0,0,0) position. Vehicle should emit
     * GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the
     * local coordinate frame and the global (GNSS) coordinate frame, which may be necessary when (for
     * example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor. This
     * command supersedes SET_GPS_GLOBAL_ORIGIN. Should be sent in a COMMAND_INT (Expected frame is
     * MAV_FRAME_GLOBAL, and this should be assumed when sent in COMMAND_LONG).
     *
     * @note has location
     *
     * @param1 Empty
     * @param2 Empty
     * @param3 Empty
     * @param4 Empty
     * @param5 Latitude Latitude
     * @param6 Longitude Longitude
     * @param7 Altitude[m] Altitude
     */
    'DO_SET_GLOBAL_ORIGIN' = 611,
    /**
     * Enable Moving Target Indicators (MTI) on streamed video. Support for feature can be checked with
     * CAMERA_CAP_FLAGS_HAS_MTI, and disabled with MAV_CMD_CAMERA_STOP_MTI.
     * @param1 Target Camera ID (min: 0, max: 255, increment: 1) Target camera ID. 7 to 255: MAVLink camera component id. 1 to 6 for cameras attached to the autopilot, which don't have a distinct component id. 0: all cameras. This is used to target specific autopilot-connected cameras. It is also used to target specific cameras when the MAV_CMD is used in a mission.
     */
    'CAMERA_START_MTI' = 2020,
    /**
     * Disable Moving Target Indicators (MTI) on streamed video.
     * @param1 Target Camera ID (min: 0, max: 255, increment: 1) Target camera ID. 7 to 255: MAVLink camera component id. 1 to 6 for cameras attached to the autopilot, which don't have a distinct component id. 0: all cameras. This is used to target specific autopilot-connected cameras. It is also used to target specific cameras when the MAV_CMD is used in a mission.
     */
    'CAMERA_STOP_MTI' = 2021,
    /**
     * Used to manually set/unset emergency status for remote id. This is for compliance with MOC ASTM
     * docs, specifically F358 section 7.7: "Emergency Status Indicator". The requirement can also be
     * satisfied by automatic setting of the emergency status by flight stack, and that approach is
     * preferred. See https://mavlink.io/en/services/opendroneid.html for more information.
     * @param1 Number (min: 0, increment: 1) Set/unset emergency 0: unset, 1: set
     * @param4 Empty
     * @param5 Empty
     * @param5 Empty
     * @param6 Empty
     * @param7 Empty
     */
    'ODID_SET_EMERGENCY' = 12900,
    /**
     * Set an external estimate of wind direction and speed. This might be used to provide an initial wind
     * estimate to the estimator (EKF) in the case where the vehicle is wind dead-reckoning, extending the
     * time when operating without GPS before before position drift builds to an unsafe level. For this use
     * case the command might reasonably be sent every few minutes when operating at altitude, and the
     * value is cleared if the estimator resets itself.
     * @param1 Wind speed[m/s] (min: 0) Horizontal wind speed.
     * @param2 Wind speed accuracy[m/s] Estimated 1 sigma accuracy of wind speed. Set to NaN if unknown.
     * @param3 Direction[deg] (min: 0, max: 360) Azimuth (relative to true north) from where the wind is blowing.
     * @param4 Direction accuracy[deg] Estimated 1 sigma accuracy of wind direction. Set to NaN if unknown.
     * @param5 Empty
     * @param6 Empty
     * @param7 Empty
     */
    'EXTERNAL_WIND_ESTIMATE' = 43004,
    /**
     * Set an external estimate of vehicle attitude. This might be used to provide an initial attitude
     * (especially heading) estimate to the estimator (EKF). Angles are defined in a 3-2-1 (yaw-pitch-roll)
     * intrinsic Tait-Bryan sequence.
     * @param1 Roll[deg] (min: 0, max: 360) Roll angle. Set to NaN if unknown.
     * @param2 Pitch[deg] (min: 0, max: 360) Pitch angle. Set to NaN if unknown.
     * @param3 Yaw[deg] (min: 0, max: 360) Yaw/heading (relative to true north) angle. Set to NaN if unknown.
     * @param4 Tilt accuracy[deg] Estimated 1 sigma accuracy of roll and pitch angles. Set to NaN if unknown.
     * @param5 Empty
     * @param6 Empty
     * @param7 Yaw accuracy[deg] Estimated 1 sigma accuracy of yaw angle. Set to NaN if unknown.
     */
    'EXTERNAL_ATTITUDE_ESTIMATE' = 620,
    /**
     * Request GCS control of a system (or of a specific component in a system). A controlled system should
     * only accept MAVLink commands and command-like messages that are sent by its controlling GCS, or from
     * other components with the same system id. Commands from other systems should be rejected with
     * MAV_RESULT_FAILED (except for this command, which may be acknowledged with MAV_RESULT_ACCEPTED if
     * control is granted). Command-like messages should be ignored (or rejected if that is supported by
     * their associated protocol). GCS control of the whole system is managed via a single component that
     * we will refer to here as the "system manager component". This component streams the CONTROL_STATUS
     * message and sets the GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER flag. Other components in the system
     * should monitor for the CONTROL_STATUS message with this flag, and set their controlling GCS to match
     * its published system id. A GCS that wants to control the system should also monitor for the same
     * message and flag, and address the MAV_CMD_REQUEST_OPERATOR_CONTROL to its component id. Note that
     * integrators are required to ensure that there is only one system manager component in the system
     * (i.e. one component emitting the message with GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER set). The
     * MAV_CMD_REQUEST_OPERATOR_CONTROL command is sent by a GCS to the system manager component to request
     * or release control of a system, specifying whether subsequent takeover requests from another GCS are
     * automatically granted, or require permission. The system manager component should grant control to
     * the GCS if the system does not require takeover permission (or is uncontrolled) and ACK the request
     * with MAV_RESULT_ACCEPTED. The system manager component should then stream CONTROL_STATUS indicating
     * its controlling system: all other components with the same system id should monitor this message and
     * set their own controlling GCS to match that of the system manager component. If the system manager
     * component cannot grant control (because takeover requires permission), the request should be
     * rejected with MAV_RESULT_FAILED. The system manager component should then send this same command to
     * the current owning GCS in order to notify of the request. The owning GCS would ACK with
     * MAV_RESULT_ACCEPTED, and might choose to release control of the vehicle, or re-request control with
     * the takeover bit set to allow permission. In case it choses to re-request control with takeover bit
     * set to allow permission, requester GCS will only have 10 seconds to get control, otherwise owning
     * GCS will re-request control with takeover bit set to disallow permission, and requester GCS will
     * need repeat the request if still interested in getting control. Note that the pilots of both GCS
     * should coordinate safe handover offline. Note that in most systems the only controlled component
     * will be the "system manager component", and that will be the autopilot. However separate GCS control
     * of a particular component is also permitted, if supported by the component. In this case the GCS
     * will address MAV_CMD_REQUEST_OPERATOR_CONTROL to the specific component it wants to control. The
     * component will then stream CONTROL_STATUS for its controlling GCS (it must not set
     * GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER). The component should fall back to the system GCS (if any)
     * when it is not directly controlled, and may stop emitting CONTROL_STATUS. The flow is otherwise the
     * same as for requesting control over the whole system.
     * @param1 Sysid requesting control System ID of GCS requesting control. 0 when command sent from GCS to autopilot (autopilot determines requesting GCS sysid from message header). Sysid of GCS requesting control when command sent by autopilot to controlling GCS.
     * @param2 Action 0: Release control, 1: Request control.
     * @param3 Allow takeover Enable automatic granting of ownership on request (by default reject request and notify current owner). 0: Ask current owner and reject request, 1: Allow automatic takeover.
     * @param4 Request timeout[s] (min: 3, max: 60) Timeout in seconds before a request to a GCS to allow takeover is assumed to be rejected. This is used to display the timeout graphically on requester and GCS in control.
     * @param5 Empty
     * @param6 Empty
     * @param7 Empty
     */
    'REQUEST_OPERATOR_CONTROL' = 32100
}
/**
 * CONTROL_STATUS flags.
 */
export declare enum GcsControlStatusFlags {
    /**
     * If set, this CONTROL_STATUS publishes the controlling GCS for the whole system. If unset, the
     * CONTROL_STATUS indicates the controlling GCS for just the component emitting the message. Note that
     * to request control of the system a GCS should send MAV_CMD_REQUEST_OPERATOR_CONTROL to the component
     * emitting CONTROL_STATUS with this flag set.
     */
    'SYSTEM_MANAGER' = 1,
    /**
     * Takeover allowed (requests for control will be granted). If not set requests for control will be
     * rejected, but the controlling GCS will be notified (and may release control or allow takeover).
     */
    'TAKEOVER_ALLOWED' = 2
}
/**
 * These flags indicate the sensor reporting capabilities for TARGET_ABSOLUTE.
 */
export declare enum TargetAbsoluteSensorCapabilityFlags {
    'POSITION' = 1,
    'VELOCITY' = 2,
    'ACCELERATION' = 4,
    'ATTITUDE' = 8,
    'RATES' = 16
}
/**
 * The frame of a target observation from an onboard sensor.
 */
export declare enum TargetObsFrame {
    /**
     * NED local tangent frame (x: North, y: East, z: Down) with origin fixed relative to earth.
     */
    'LOCAL_NED' = 0,
    /**
     * FRD local frame aligned to the vehicle's attitude (x: Forward, y: Right, z: Down) with an origin
     * that travels with vehicle.
     */
    'BODY_FRD' = 1,
    /**
     * NED local tangent frame (x: North, y: East, z: Down) with an origin that travels with vehicle.
     */
    'LOCAL_OFFSET_NED' = 2,
    /**
     * Other sensor frame for target observations neither in local NED nor in body FRD.
     */
    'OTHER' = 3
}
/**
 * RADIO_RC_CHANNELS flags (bitmask).
 */
export declare enum RadioRcChannelsFlags {
    /**
     * Failsafe is active. The content of the RC channels data in the RADIO_RC_CHANNELS message is
     * implementation dependent.
     */
    'FAILSAFE' = 1,
    /**
     * Channel data may be out of date. This is set when the receiver is unable to validate incoming data
     * from the transmitter and has therefore resent the last valid data it received.
     */
    'OUTDATED' = 2
}
/**
 * Flags indicating errors in a GPS receiver.
 */
export declare enum GpsSystemErrorFlags {
    /**
     * There are problems with incoming correction streams.
     */
    'INCOMING_CORRECTIONS' = 1,
    /**
     * There are problems with the configuration.
     */
    'CONFIGURATION' = 2,
    /**
     * There are problems with the software on the GPS receiver.
     */
    'SOFTWARE' = 4,
    /**
     * There are problems with an antenna connected to the GPS receiver.
     */
    'ANTENNA' = 8,
    /**
     * There are problems handling all incoming events.
     */
    'EVENT_CONGESTION' = 16,
    /**
     * The GPS receiver CPU is overloaded.
     */
    'CPU_OVERLOAD' = 32,
    /**
     * The GPS receiver is experiencing output congestion.
     */
    'OUTPUT_CONGESTION' = 64
}
/**
 * Signal authentication state in a GPS receiver.
 */
export declare enum GpsAuthenticationState {
    /**
     * The GPS receiver does not provide GPS signal authentication info.
     */
    'UNKNOWN' = 0,
    /**
     * The GPS receiver is initializing signal authentication.
     */
    'INITIALIZING' = 1,
    /**
     * The GPS receiver encountered an error while initializing signal authentication.
     */
    'ERROR' = 2,
    /**
     * The GPS receiver has correctly authenticated all signals.
     */
    'OK' = 3,
    /**
     * GPS signal authentication is disabled on the receiver.
     */
    'DISABLED' = 4
}
/**
 * Signal jamming state in a GPS receiver.
 */
export declare enum GpsJammingState {
    /**
     * The GPS receiver does not provide GPS signal jamming info.
     */
    'UNKNOWN' = 0,
    /**
     * The GPS receiver detected no signal jamming.
     */
    'OK' = 1,
    /**
     * The GPS receiver detected and mitigated signal jamming.
     */
    'MITIGATED' = 2,
    /**
     * The GPS receiver detected signal jamming.
     */
    'DETECTED' = 3
}
/**
 * Signal spoofing state in a GPS receiver.
 */
export declare enum GpsSpoofingState {
    /**
     * The GPS receiver does not provide GPS signal spoofing info.
     */
    'UNKNOWN' = 0,
    /**
     * The GPS receiver detected no signal spoofing.
     */
    'OK' = 1,
    /**
     * The GPS receiver detected and mitigated signal spoofing.
     */
    'MITIGATED' = 2,
    /**
     * The GPS receiver detected signal spoofing but still has a fix.
     */
    'DETECTED' = 3
}
/**
 * State of RAIM processing.
 */
export declare enum GpsRaimState {
    /**
     * RAIM capability is unknown.
     */
    'UNKNOWN' = 0,
    /**
     * RAIM is disabled.
     */
    'DISABLED' = 1,
    /**
     * RAIM integrity check was successful.
     */
    'OK' = 2,
    /**
     * RAIM integrity check failed.
     */
    'FAILED' = 3
}
/**
 * Actuator groups to test in MAV_CMD_ACTUATOR_GROUP_TEST.
 */
export declare enum ActuatorTestGroup {
    /**
     * Actuators that contribute to roll torque.
     */
    'ROLL_TORQUE' = 0,
    /**
     * Actuators that contribute to pitch torque.
     */
    'PITCH_TORQUE' = 1,
    /**
     * Actuators that contribute to yaw torque.
     */
    'YAW_TORQUE' = 2,
    /**
     * Actuators that affect collective tilt.
     */
    'COLLECTIVE_TILT' = 3
}
/**
 * Source for GLOBAL_POSITION measurement or estimate.
 */
export declare enum GlobalPositionSrc {
    /**
     * Source is unknown or not one of the listed types.
     */
    'UNKNOWN' = 0,
    /**
     * Global Navigation Satellite System (e.g.: GPS, Galileo, Glonass, BeiDou).
     */
    'GNSS' = 1,
    /**
     * Vision system (e.g.: map matching).
     */
    'VISION' = 2,
    /**
     * Pseudo-satellite system (performs GNSS-like function, but usually with transceiver beacons).
     */
    'PSEUDOLITES' = 3,
    /**
     * Terrain referenced navigation.
     */
    'TRN' = 4,
    /**
     * Magnetic positioning.
     */
    'MAGNETIC' = 5,
    /**
     * Estimated position based on various sensors (eg. a Kalman Filter).
     */
    'ESTIMATOR' = 6
}
/**
 * Status flags for GLOBAL_POSITION
 */
export declare enum GlobalPositionFlags {
    /**
     * Unhealthy sensor/estimator.
     */
    'UNHEALTHY' = 1,
    /**
     * True if the data originates from or is consumed by the primary estimator.
     */
    'PRIMARY' = 2
}
/**
 * Airspeed information from a sensor.
 */
export declare class Airspeed extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * Sensor ID.
     */
    id: uint8_t;
    /**
     * Calibrated airspeed (CAS).
     * Units: m/s
     */
    airspeed: float;
    /**
     * Temperature. INT16_MAX for value unknown/not supplied.
     * Units: cdegC
     */
    temperature: int16_t;
    /**
     * Raw differential pressure. NaN for value unknown/not supplied.
     * Units: hPa
     */
    rawPress: float;
    /**
     * Airspeed sensor flags.
     */
    flags: AirspeedSensorFlags;
}
/**
 * Global position measurement or estimate.
 */
export declare class GlobalPosition extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * Sensor ID
     */
    id: uint8_t;
    /**
     * Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format
     * (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
     * Units: us
     */
    timeUsec: uint64_t;
    /**
     * Source of position/estimate (such as GNSS, estimator, etc.)
     */
    source: GlobalPositionSrc;
    /**
     * Status flags
     */
    flags: GlobalPositionFlags;
    /**
     * Latitude (WGS84)
     * Units: degE7
     */
    lat: int32_t;
    /**
     * Longitude (WGS84)
     * Units: degE7
     */
    lon: int32_t;
    /**
     * Altitude (MSL - position-system specific value)
     * Units: m
     */
    alt: float;
    /**
     * Altitude (WGS84 elipsoid)
     * Units: m
     */
    altEllipsoid: float;
    /**
     * Standard deviation of horizontal position error
     * Units: m
     */
    eph: float;
    /**
     * Standard deviation of vertical position error
     * Units: m
     */
    epv: float;
}
/**
 * Battery dynamic information. This should be streamed (nominally at 1Hz). Static/invariant battery
 * information is sent in BATTERY_INFO. Note that smart batteries should set the
 * MAV_BATTERY_STATUS_FLAGS_CAPACITY_RELATIVE_TO_FULL bit to indicate that supplied capacity values are
 * relative to a battery that is known to be full. Power monitors would not set this bit, indicating
 * that capacity_consumed is relative to drone power-on, and that other values are estimated based on
 * the assumption that the battery was full on power-on.
 */
export declare class BatteryStatusV2 extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * Battery ID
     */
    id: uint8_t;
    /**
     * Temperature of the whole battery pack (not internal electronics). INT16_MAX field not provided.
     * Units: cdegC
     */
    temperature: int16_t;
    /**
     * Battery voltage (total). NaN: field not provided.
     * Units: V
     */
    voltage: float;
    /**
     * Battery current (through all cells/loads). Positive value when discharging and negative if charging.
     * NaN: field not provided.
     * Units: A
     */
    current: float;
    /**
     * Consumed charge. NaN: field not provided. This is either the consumption since power-on or since the
     * battery was full, depending on the value of MAV_BATTERY_STATUS_FLAGS_CAPACITY_RELATIVE_TO_FULL.
     * Units: Ah
     */
    capacityConsumed: float;
    /**
     * Remaining charge (until empty). NaN: field not provided. Note: If
     * MAV_BATTERY_STATUS_FLAGS_CAPACITY_RELATIVE_TO_FULL is unset, this value is based on the assumption
     * the battery was full when the system was powered.
     * Units: Ah
     */
    capacityRemaining: float;
    /**
     * Remaining battery energy. Values: [0-100], UINT8_MAX: field not provided.
     * Units: %
     */
    percentRemaining: uint8_t;
    /**
     * Fault, health, readiness, and other status indications.
     */
    statusFlags: MavBatteryStatusFlags;
}
/**
 * Emitted during mission execution when control reaches MAV_CMD_GROUP_START.
 */
export declare class GroupStart extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * Mission-unique group id (from MAV_CMD_GROUP_START).
     */
    groupId: uint32_t;
    /**
     * CRC32 checksum of current plan for MAV_MISSION_TYPE_ALL. As defined in MISSION_CHECKSUM message.
     */
    missionChecksum: uint32_t;
    /**
     * Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format
     * (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
     * Units: us
     */
    timeUsec: uint64_t;
}
/**
 * Emitted during mission execution when control reaches MAV_CMD_GROUP_END.
 */
export declare class GroupEnd extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * Mission-unique group id (from MAV_CMD_GROUP_END).
     */
    groupId: uint32_t;
    /**
     * CRC32 checksum of current plan for MAV_MISSION_TYPE_ALL. As defined in MISSION_CHECKSUM message.
     */
    missionChecksum: uint32_t;
    /**
     * Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format
     * (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
     * Units: us
     */
    timeUsec: uint64_t;
}
/**
 * RC channel outputs from a MAVLink RC receiver for input to a flight controller or other components
 * (allows an RC receiver to connect via MAVLink instead of some other protocol such as PPM-Sum or
 * S.BUS). Note that this is not intended to be an over-the-air format, and does not replace
 * RC_CHANNELS and similar messages reported by the flight controller. The target_system field should
 * normally be set to the system id of the system to control, typically the flight controller. The
 * target_component field can normally be set to 0, so that all components of the system can receive
 * the message. The channels array field can publish up to 32 channels; the number of channel items
 * used in the array is specified in the count field. The time_last_update_ms field contains the
 * timestamp of the last received valid channels data in the receiver's time domain. The count field
 * indicates the first index of the channel array that is not used for channel data (this and later
 * indexes are zero-filled). The RADIO_RC_CHANNELS_FLAGS_OUTDATED flag is set by the receiver if the
 * channels data is not up-to-date (for example, if new data from the transmitter could not be
 * validated so the last valid data is resent). The RADIO_RC_CHANNELS_FLAGS_FAILSAFE failsafe flag is
 * set by the receiver if the receiver's failsafe condition is met (implementation dependent, e.g.,
 * connection to the RC radio is lost). In this case time_last_update_ms still contains the timestamp
 * of the last valid channels data, but the content of the channels data is not defined by the protocol
 * (it is up to the implementation of the receiver). For instance, the channels data could contain
 * failsafe values configured in the receiver; the default is to carry the last valid data. Note: The
 * RC channels fields are extensions to ensure that they are located at the end of the serialized
 * payload and subject to MAVLink's trailing-zero trimming.
 */
export declare class RadioRcChannels extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * System ID (ID of target system, normally flight controller).
     */
    targetSystem: uint8_t;
    /**
     * Component ID (normally 0 for broadcast).
     */
    targetComponent: uint8_t;
    /**
     * Time when the data in the channels field were last updated (time since boot in the receiver's time
     * domain).
     * Units: ms
     */
    timeLastUpdateMs: uint32_t;
    /**
     * Radio RC channels status flags.
     */
    flags: RadioRcChannelsFlags;
    /**
     * Total number of RC channels being received. This can be larger than 32, indicating that more
     * channels are available but not given in this message.
     */
    count: uint8_t;
    /**
     * RC channels. Channel values are in centered 13 bit format. Range is -4096 to 4096, center is 0.
     * Conversion to PWM is x * 5/32 + 1500. Channels with indexes equal or above count should be set to 0,
     * to benefit from MAVLink's trailing-zero trimming.
     */
    channels: int16_t[];
}
/**
 * Information about key components of GNSS receivers, like signal authentication, interference and
 * system errors.
 */
export declare class GnssIntegrity extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * GNSS receiver id. Must match instance ids of other messages from same receiver.
     */
    id: uint8_t;
    /**
     * Errors in the GPS system.
     */
    systemErrors: GpsSystemErrorFlags;
    /**
     * Signal authentication state of the GPS system.
     */
    authenticationState: GpsAuthenticationState;
    /**
     * Signal jamming state of the GPS system.
     */
    jammingState: GpsJammingState;
    /**
     * Signal spoofing state of the GPS system.
     */
    spoofingState: GpsSpoofingState;
    /**
     * The state of the RAIM processing.
     */
    raimState: GpsRaimState;
    /**
     * Horizontal expected accuracy using satellites successfully validated using RAIM.
     * Units: cm
     */
    raimHfom: uint16_t;
    /**
     * Vertical expected accuracy using satellites successfully validated using RAIM.
     * Units: cm
     */
    raimVfom: uint16_t;
    /**
     * An abstract value representing the estimated quality of incoming corrections, or 255 if not
     * available.
     */
    correctionsQuality: uint8_t;
    /**
     * An abstract value representing the overall status of the receiver, or 255 if not available.
     */
    systemStatusSummary: uint8_t;
    /**
     * An abstract value representing the quality of incoming GNSS signals, or 255 if not available.
     */
    gnssSignalQuality: uint8_t;
    /**
     * An abstract value representing the estimated PPK quality, or 255 if not available.
     */
    postProcessingQuality: uint8_t;
}
/**
 * Current motion information from sensors on a target
 */
export declare class TargetAbsolute extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * Timestamp (UNIX epoch time).
     * Units: us
     */
    timestamp: uint64_t;
    /**
     * The ID of the target if multiple targets are present
     */
    id: uint8_t;
    /**
     * Bitmap to indicate the sensor's reporting capabilities
     */
    sensorCapabilities: TargetAbsoluteSensorCapabilityFlags;
    /**
     * Target's latitude (WGS84)
     * Units: degE7
     */
    lat: int32_t;
    /**
     * Target's longitude (WGS84)
     * Units: degE7
     */
    lon: int32_t;
    /**
     * Target's altitude (AMSL)
     * Units: m
     */
    alt: float;
    /**
     * Target's velocity in its body frame
     * Units: m/s
     */
    vel: float[];
    /**
     * Linear target's acceleration in its body frame
     * Units: m/s/s
     */
    acc: float[];
    /**
     * Quaternion of the target's orientation from its body frame to the vehicle's NED frame.
     */
    qTarget: float[];
    /**
     * Target's roll, pitch and yaw rates
     * Units: rad/s
     */
    rates: float[];
    /**
     * Standard deviation of horizontal (eph) and vertical (epv) position errors
     * Units: m
     */
    positionStd: float[];
    /**
     * Standard deviation of the target's velocity in its body frame
     * Units: m/s
     */
    velStd: float[];
    /**
     * Standard deviation of the target's acceleration in its body frame
     * Units: m/s/s
     */
    accStd: float[];
}
/**
 * The location of a target measured by MAV's onboard sensors.
 */
export declare class TargetRelative extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * Timestamp (UNIX epoch time)
     * Units: us
     */
    timestamp: uint64_t;
    /**
     * The ID of the target if multiple targets are present
     */
    id: uint8_t;
    /**
     * Coordinate frame used for following fields.
     */
    frame: TargetObsFrame;
    /**
     * X Position of the target in TARGET_OBS_FRAME
     * Units: m
     */
    x: float;
    /**
     * Y Position of the target in TARGET_OBS_FRAME
     * Units: m
     */
    y: float;
    /**
     * Z Position of the target in TARGET_OBS_FRAME
     * Units: m
     */
    z: float;
    /**
     * Standard deviation of the target's position in TARGET_OBS_FRAME
     * Units: m
     */
    posStd: float[];
    /**
     * Standard deviation of the target's orientation in TARGET_OBS_FRAME
     * Units: rad
     */
    yawStd: float;
    /**
     * Quaternion of the target's orientation from the target's frame to the TARGET_OBS_FRAME (w, x, y, z
     * order, zero-rotation is 1, 0, 0, 0)
     */
    qTarget: float[];
    /**
     * Quaternion of the sensor's orientation from TARGET_OBS_FRAME to vehicle-carried NED. (Ignored if set
     * to (0,0,0,0)) (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
     */
    qSensor: float[];
    /**
     * Type of target
     */
    type: LandingTargetType;
}
/**
 * Information about GCS in control of this MAV. This should be broadcast at low rate (nominally 1 Hz)
 * and emitted when ownership or takeover status change. Control over MAV is requested using
 * MAV_CMD_REQUEST_OPERATOR_CONTROL.
 */
export declare class ControlStatus extends MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
    constructor();
    /**
     * System ID of GCS MAVLink component in control (0: no GCS in control).
     */
    sysidInControl: uint8_t;
    /**
     * Control status. For example, whether takeover is allowed, and whether this message instance defines
     * the default controlling GCS for the whole system.
     */
    flags: GcsControlStatusFlags;
}
import { CommandLong } from './common';
/**
 * Fly a figure eight path as defined by the parameters. Set parameters to NaN/INT32_MAX (as
 * appropriate) to use system-default values. The command is intended for fixed wing vehicles (and VTOL
 * hybrids flying in fixed-wing mode), allowing POI tracking for gimbals that don't support infinite
 * rotation. This command only defines the flight path. Speed should be set independently (use e.g.
 * MAV_CMD_DO_CHANGE_SPEED). Yaw and other degrees of freedom are not specified, and will be
 * flight-stack specific (on vehicles where they can be controlled independent of the heading).
 *
 * This command has location.
 * This command is destination.
 */
export declare class DoFigureEightCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Major axis radius of the figure eight. Positive: orbit the north circle clockwise. Negative: orbit
     * the north circle counter-clockwise. NaN: The radius will be set to 2.5 times the minor radius and
     * direction is clockwise. Must be greater or equal to two times the minor radius for feasible values.
     *
     * @units m
     */
    get majorRadius(): number;
    set majorRadius(value: number);
    /**
     * Minor axis radius of the figure eight. Defines the radius of the two circles that make up the
     * figure. Negative value has no effect. NaN: The radius will be set to the default loiter radius.
     *
     * @units m
     */
    get minorRadius(): number;
    set minorRadius(value: number);
    /**
     * Orientation of the figure eight major axis with respect to true north (range: [-pi,pi]). NaN: use
     * default orientation aligned to true north.
     *
     * @units rad
     */
    get orientation(): number;
    set orientation(value: number);
    /**
     * Center point latitude/X coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle position, or current center if
     * already loitering.
     */
    get latitude(): number;
    set latitude(value: number);
    /**
     * Center point longitude/Y coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle position, or current center if
     * already loitering.
     */
    get longitude(): number;
    set longitude(value: number);
    /**
     * Center point altitude MSL/Z coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle altitude.
     */
    get altitude(): number;
    set altitude(value: number);
}
/**
 * Request a target system to start an upgrade of one (or all) of its components. For example, the
 * command might be sent to a companion computer to cause it to upgrade a connected flight controller.
 * The system doing the upgrade will report progress using the normal command protocol sequence for a
 * long running operation. Command protocol information: https://mavlink.io/en/services/command.html.
 */
export declare class DoUpgradeCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Component id of the component to be upgraded. If set to 0, all components should be upgraded.
     */
    get componentId(): number;
    set componentId(value: number);
    /**
     * 0: Do not reboot component after the action is executed, 1: Reboot component after the action is
     * executed.
     *
     * @min: 0
     * @max: 1
     * @increment: 1
     */
    get reboot(): number;
    set reboot(value: number);
}
/**
 * Command to test groups of related actuators together. This might include groups such as the
 * actuators that contribute to roll, pitch, or yaw torque, actuators that contribute to thrust in x,
 * y, z axis, tilt mechanisms, flaps and spoilers, and so on. This is similar to MAV_CMD_ACTUATOR_TEST,
 * except that multiple actuators may be affected. Different groups may also affect the same actuators
 * (as in the case of controls that affect torque in different axes). Autopilots must NACK this command
 * with MAV_RESULT_TEMPORARILY_REJECTED while armed.
 */
export declare class ActuatorGroupTestCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Actuator group to check, such as actuators related to roll torque.
     */
    get group(): number;
    set group(value: number);
    /**
     * Value to set. This is a normalized value across the full range of the tested group [-1,1].
     *
     * @min: -1
     * @max: 1
     */
    get value(): number;
    set value(value: number);
}
/**
 * Set system and component id. This allows moving of a system and all its components to a new system
 * id, or moving a particular component to a new system/component id. Recipients must reject command
 * addressed to broadcast system ID.
 */
export declare class DoSetSysCmpIdCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * New system ID for target component(s). 0: ignore and reject command (broadcast system ID not
     * allowed).
     *
     * @min: 1
     * @max: 255
     * @increment: 1
     */
    get systemId(): number;
    set systemId(value: number);
    /**
     * New component ID for target component(s). 0: ignore (component IDs don't change).
     *
     * @min: 0
     * @max: 255
     * @increment: 1
     */
    get componentId(): number;
    set componentId(value: number);
    /**
     * Reboot components after ID change. Any non-zero value triggers the reboot.
     */
    get reboot(): number;
    set reboot(value: number);
}
/**
 * Sets the GNSS coordinates of the vehicle local origin (0,0,0) position. Vehicle should emit
 * GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the
 * local coordinate frame and the global (GNSS) coordinate frame, which may be necessary when (for
 * example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor. This
 * command supersedes SET_GPS_GLOBAL_ORIGIN. Should be sent in a COMMAND_INT (Expected frame is
 * MAV_FRAME_GLOBAL, and this should be assumed when sent in COMMAND_LONG).
 *
 * This command has location.
 */
export declare class DoSetGlobalOriginCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Latitude
     */
    get latitude(): number;
    set latitude(value: number);
    /**
     * Longitude
     */
    get longitude(): number;
    set longitude(value: number);
    /**
     * Altitude
     *
     * @units m
     */
    get altitude(): number;
    set altitude(value: number);
}
/**
 * Enable Moving Target Indicators (MTI) on streamed video. Support for feature can be checked with
 * CAMERA_CAP_FLAGS_HAS_MTI, and disabled with MAV_CMD_CAMERA_STOP_MTI.
 */
export declare class CameraStartMtiCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Target camera ID. 7 to 255: MAVLink camera component id. 1 to 6 for cameras attached to the
     * autopilot, which don't have a distinct component id. 0: all cameras. This is used to target specific
     * autopilot-connected cameras. It is also used to target specific cameras when the MAV_CMD is used in
     * a mission.
     *
     * @min: 0
     * @max: 255
     * @increment: 1
     */
    get targetCameraId(): number;
    set targetCameraId(value: number);
}
/**
 * Disable Moving Target Indicators (MTI) on streamed video.
 */
export declare class CameraStopMtiCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Target camera ID. 7 to 255: MAVLink camera component id. 1 to 6 for cameras attached to the
     * autopilot, which don't have a distinct component id. 0: all cameras. This is used to target specific
     * autopilot-connected cameras. It is also used to target specific cameras when the MAV_CMD is used in
     * a mission.
     *
     * @min: 0
     * @max: 255
     * @increment: 1
     */
    get targetCameraId(): number;
    set targetCameraId(value: number);
}
/**
 * Used to manually set/unset emergency status for remote id. This is for compliance with MOC ASTM
 * docs, specifically F358 section 7.7: "Emergency Status Indicator". The requirement can also be
 * satisfied by automatic setting of the emergency status by flight stack, and that approach is
 * preferred. See https://mavlink.io/en/services/opendroneid.html for more information.
 */
export declare class OdidSetEmergencyCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Set/unset emergency 0: unset, 1: set
     *
     * @min: 0
     * @increment: 1
     */
    get number(): number;
    set number(value: number);
}
/**
 * Set an external estimate of wind direction and speed. This might be used to provide an initial wind
 * estimate to the estimator (EKF) in the case where the vehicle is wind dead-reckoning, extending the
 * time when operating without GPS before before position drift builds to an unsafe level. For this use
 * case the command might reasonably be sent every few minutes when operating at altitude, and the
 * value is cleared if the estimator resets itself.
 */
export declare class ExternalWindEstimateCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Horizontal wind speed.
     *
     * @units m/s
     * @min: 0
     */
    get windSpeed(): number;
    set windSpeed(value: number);
    /**
     * Estimated 1 sigma accuracy of wind speed. Set to NaN if unknown.
     *
     * @units m/s
     */
    get windSpeedAccuracy(): number;
    set windSpeedAccuracy(value: number);
    /**
     * Azimuth (relative to true north) from where the wind is blowing.
     *
     * @units deg
     * @min: 0
     * @max: 360
     */
    get direction(): number;
    set direction(value: number);
    /**
     * Estimated 1 sigma accuracy of wind direction. Set to NaN if unknown.
     *
     * @units deg
     */
    get directionAccuracy(): number;
    set directionAccuracy(value: number);
}
/**
 * Set an external estimate of vehicle attitude. This might be used to provide an initial attitude
 * (especially heading) estimate to the estimator (EKF). Angles are defined in a 3-2-1 (yaw-pitch-roll)
 * intrinsic Tait-Bryan sequence.
 */
export declare class ExternalAttitudeEstimateCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * Roll angle. Set to NaN if unknown.
     *
     * @units deg
     * @min: 0
     * @max: 360
     */
    get roll(): number;
    set roll(value: number);
    /**
     * Pitch angle. Set to NaN if unknown.
     *
     * @units deg
     * @min: 0
     * @max: 360
     */
    get pitch(): number;
    set pitch(value: number);
    /**
     * Yaw/heading (relative to true north) angle. Set to NaN if unknown.
     *
     * @units deg
     * @min: 0
     * @max: 360
     */
    get yaw(): number;
    set yaw(value: number);
    /**
     * Estimated 1 sigma accuracy of roll and pitch angles. Set to NaN if unknown.
     *
     * @units deg
     */
    get tiltAccuracy(): number;
    set tiltAccuracy(value: number);
    /**
     * Estimated 1 sigma accuracy of yaw angle. Set to NaN if unknown.
     *
     * @units deg
     */
    get yawAccuracy(): number;
    set yawAccuracy(value: number);
}
/**
 * Request GCS control of a system (or of a specific component in a system). A controlled system should
 * only accept MAVLink commands and command-like messages that are sent by its controlling GCS, or from
 * other components with the same system id. Commands from other systems should be rejected with
 * MAV_RESULT_FAILED (except for this command, which may be acknowledged with MAV_RESULT_ACCEPTED if
 * control is granted). Command-like messages should be ignored (or rejected if that is supported by
 * their associated protocol). GCS control of the whole system is managed via a single component that
 * we will refer to here as the "system manager component". This component streams the CONTROL_STATUS
 * message and sets the GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER flag. Other components in the system
 * should monitor for the CONTROL_STATUS message with this flag, and set their controlling GCS to match
 * its published system id. A GCS that wants to control the system should also monitor for the same
 * message and flag, and address the MAV_CMD_REQUEST_OPERATOR_CONTROL to its component id. Note that
 * integrators are required to ensure that there is only one system manager component in the system
 * (i.e. one component emitting the message with GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER set). The
 * MAV_CMD_REQUEST_OPERATOR_CONTROL command is sent by a GCS to the system manager component to request
 * or release control of a system, specifying whether subsequent takeover requests from another GCS are
 * automatically granted, or require permission. The system manager component should grant control to
 * the GCS if the system does not require takeover permission (or is uncontrolled) and ACK the request
 * with MAV_RESULT_ACCEPTED. The system manager component should then stream CONTROL_STATUS indicating
 * its controlling system: all other components with the same system id should monitor this message and
 * set their own controlling GCS to match that of the system manager component. If the system manager
 * component cannot grant control (because takeover requires permission), the request should be
 * rejected with MAV_RESULT_FAILED. The system manager component should then send this same command to
 * the current owning GCS in order to notify of the request. The owning GCS would ACK with
 * MAV_RESULT_ACCEPTED, and might choose to release control of the vehicle, or re-request control with
 * the takeover bit set to allow permission. In case it choses to re-request control with takeover bit
 * set to allow permission, requester GCS will only have 10 seconds to get control, otherwise owning
 * GCS will re-request control with takeover bit set to disallow permission, and requester GCS will
 * need repeat the request if still interested in getting control. Note that the pilots of both GCS
 * should coordinate safe handover offline. Note that in most systems the only controlled component
 * will be the "system manager component", and that will be the autopilot. However separate GCS control
 * of a particular component is also permitted, if supported by the component. In this case the GCS
 * will address MAV_CMD_REQUEST_OPERATOR_CONTROL to the specific component it wants to control. The
 * component will then stream CONTROL_STATUS for its controlling GCS (it must not set
 * GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER). The component should fall back to the system GCS (if any)
 * when it is not directly controlled, and may stop emitting CONTROL_STATUS. The flow is otherwise the
 * same as for requesting control over the whole system.
 */
export declare class RequestOperatorControlCommand extends CommandLong {
    constructor(targetSystem?: number, targetComponent?: number);
    /**
     * System ID of GCS requesting control. 0 when command sent from GCS to autopilot (autopilot determines
     * requesting GCS sysid from message header). Sysid of GCS requesting control when command sent by
     * autopilot to controlling GCS.
     */
    get sysidRequestingControl(): number;
    set sysidRequestingControl(value: number);
    /**
     * 0: Release control, 1: Request control.
     */
    get action(): number;
    set action(value: number);
    /**
     * Enable automatic granting of ownership on request (by default reject request and notify current
     * owner). 0: Ask current owner and reject request, 1: Allow automatic takeover.
     */
    get allowTakeover(): number;
    set allowTakeover(value: number);
    /**
     * Timeout in seconds before a request to a GCS to allow takeover is assumed to be rejected. This is
     * used to display the timeout graphically on requester and GCS in control.
     *
     * @units s
     * @min: 3
     * @max: 60
     */
    get requestTimeout(): number;
    set requestTimeout(value: number);
}
export declare const REGISTRY: MavLinkPacketRegistry;
export declare const COMMANDS: MavLinkCommandRegistry;
