"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.COMMANDS = exports.REGISTRY = exports.RequestOperatorControlCommand = exports.ExternalAttitudeEstimateCommand = exports.ExternalWindEstimateCommand = exports.OdidSetEmergencyCommand = exports.CameraStopMtiCommand = exports.CameraStartMtiCommand = exports.DoSetGlobalOriginCommand = exports.DoSetSysCmpIdCommand = exports.ActuatorGroupTestCommand = exports.DoUpgradeCommand = exports.DoFigureEightCommand = exports.ControlStatus = exports.TargetRelative = exports.TargetAbsolute = exports.GnssIntegrity = exports.RadioRcChannels = exports.GroupEnd = exports.GroupStart = exports.BatteryStatusV2 = exports.GlobalPosition = exports.Airspeed = exports.GlobalPositionFlags = exports.GlobalPositionSrc = exports.ActuatorTestGroup = exports.GpsRaimState = exports.GpsSpoofingState = exports.GpsJammingState = exports.GpsAuthenticationState = exports.GpsSystemErrorFlags = exports.RadioRcChannelsFlags = exports.TargetObsFrame = exports.TargetAbsoluteSensorCapabilityFlags = exports.GcsControlStatusFlags = exports.MavCmd = exports.MavBatteryStatusFlags = exports.AirspeedSensorFlags = void 0;
const mavlink_1 = require("./mavlink");
const common_1 = require("./common");
/**
 * Airspeed sensor flags
 */
var AirspeedSensorFlags;
(function (AirspeedSensorFlags) {
    /**
     * Airspeed sensor is unhealthy
     */
    AirspeedSensorFlags[AirspeedSensorFlags["UNHEALTHY"] = 1] = "UNHEALTHY";
    /**
     * True if the data from this sensor is being actively used by the flight controller for guidance,
     * navigation or control.
     */
    AirspeedSensorFlags[AirspeedSensorFlags["USING"] = 2] = "USING";
})(AirspeedSensorFlags = exports.AirspeedSensorFlags || (exports.AirspeedSensorFlags = {}));
/**
 * Battery status flags for fault, health and state indication.
 */
var MavBatteryStatusFlags;
(function (MavBatteryStatusFlags) {
    /**
     * The battery is not ready to use (fly). Set if the battery has faults or other conditions that make
     * it unsafe to fly with. Note: It will be the logical OR of other status bits (chosen by the
     * manufacturer/integrator).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["NOT_READY_TO_USE"] = 1] = "NOT_READY_TO_USE";
    /**
     * Battery is charging.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["CHARGING"] = 2] = "CHARGING";
    /**
     * Battery is cell balancing (during charging). Not ready to use
     * (MAV_BATTERY_STATUS_FLAGS_NOT_READY_TO_USE may be set).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["CELL_BALANCING"] = 4] = "CELL_BALANCING";
    /**
     * Battery cells are not balanced. Not ready to use.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_CELL_IMBALANCE"] = 8] = "FAULT_CELL_IMBALANCE";
    /**
     * Battery is auto discharging (towards storage level). Not ready to use
     * (MAV_BATTERY_STATUS_FLAGS_NOT_READY_TO_USE would be set).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["AUTO_DISCHARGING"] = 16] = "AUTO_DISCHARGING";
    /**
     * Battery requires service (not safe to fly). This is set at vendor discretion. It is likely to be set
     * for most faults, and may also be set according to a maintenance schedule (such as age, or number of
     * recharge cycles, etc.).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["REQUIRES_SERVICE"] = 32] = "REQUIRES_SERVICE";
    /**
     * Battery is faulty and cannot be repaired (not safe to fly). This is set at vendor discretion. The
     * battery should be disposed of safely.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["BAD_BATTERY"] = 64] = "BAD_BATTERY";
    /**
     * Automatic battery protection monitoring is enabled. When enabled, the system will monitor for
     * certain kinds of faults, such as cells being over-voltage. If a fault is triggered then and
     * protections are enabled then a safety fault (MAV_BATTERY_STATUS_FLAGS_FAULT_PROTECTION_SYSTEM) will
     * be set and power from the battery will be stopped. Note that battery protection monitoring should
     * only be enabled when the vehicle is landed. Once the vehicle is armed, or starts moving, the
     * protections should be disabled to prevent false positives from disabling the output.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["PROTECTIONS_ENABLED"] = 128] = "PROTECTIONS_ENABLED";
    /**
     * The battery fault protection system had detected a fault and cut all power from the battery. This
     * will only trigger if MAV_BATTERY_STATUS_FLAGS_PROTECTIONS_ENABLED is set. Other faults like
     * MAV_BATTERY_STATUS_FLAGS_FAULT_OVER_VOLT may also be set, indicating the cause of the protection
     * fault.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_PROTECTION_SYSTEM"] = 256] = "FAULT_PROTECTION_SYSTEM";
    /**
     * One or more cells are above their maximum voltage rating.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_OVER_VOLT"] = 512] = "FAULT_OVER_VOLT";
    /**
     * One or more cells are below their minimum voltage rating. A battery that had deep-discharged might
     * be irrepairably damaged, and set both MAV_BATTERY_STATUS_FLAGS_FAULT_UNDER_VOLT and
     * MAV_BATTERY_STATUS_FLAGS_BAD_BATTERY.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_UNDER_VOLT"] = 1024] = "FAULT_UNDER_VOLT";
    /**
     * Over-temperature fault.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_OVER_TEMPERATURE"] = 2048] = "FAULT_OVER_TEMPERATURE";
    /**
     * Under-temperature fault.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_UNDER_TEMPERATURE"] = 4096] = "FAULT_UNDER_TEMPERATURE";
    /**
     * Over-current fault.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_OVER_CURRENT"] = 8192] = "FAULT_OVER_CURRENT";
    /**
     * Short circuit event detected. The battery may or may not be safe to use (check other flags).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_SHORT_CIRCUIT"] = 16384] = "FAULT_SHORT_CIRCUIT";
    /**
     * Voltage not compatible with power rail voltage (batteries on same power rail should have similar
     * voltage).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_INCOMPATIBLE_VOLTAGE"] = 32768] = "FAULT_INCOMPATIBLE_VOLTAGE";
    /**
     * Battery firmware is not compatible with current autopilot firmware.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_INCOMPATIBLE_FIRMWARE"] = 65536] = "FAULT_INCOMPATIBLE_FIRMWARE";
    /**
     * Battery is not compatible due to cell configuration (e.g. 5s1p when vehicle requires 6s).
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["FAULT_INCOMPATIBLE_CELLS_CONFIGURATION"] = 131072] = "FAULT_INCOMPATIBLE_CELLS_CONFIGURATION";
    /**
     * Battery capacity_consumed and capacity_remaining values are relative to a full battery (they sum to
     * the total capacity of the battery). This flag would be set for a smart battery that can accurately
     * determine its remaining charge across vehicle reboots and discharge/recharge cycles. If unset the
     * capacity_consumed indicates the consumption since vehicle power-on, as measured using a power
     * monitor. The capacity_remaining, if provided, indicates the estimated remaining capacity on the
     * assumption that the battery was full on vehicle boot. If unset a GCS is recommended to advise that
     * users fully charge the battery on power on.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["CAPACITY_RELATIVE_TO_FULL"] = 262144] = "CAPACITY_RELATIVE_TO_FULL";
    /**
     * Reserved (not used). If set, this will indicate that an additional status field exists for higher
     * status values.
     */
    MavBatteryStatusFlags[MavBatteryStatusFlags["EXTENDED"] = 2147483648] = "EXTENDED";
})(MavBatteryStatusFlags = exports.MavBatteryStatusFlags || (exports.MavBatteryStatusFlags = {}));
/**
 * Commands to be executed by the MAV. They can be executed on user request, or as part of a mission
 * script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is
 * as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list
 * is similar what ARINC 424 is for commercial aircraft: A data format how to interpret
 * waypoint/mission data. NaN and INT32_MAX may be used in float/integer params (respectively) to
 * indicate optional/default values (e.g. to use the component's current yaw or latitude rather than a
 * specific value). See https://mavlink.io/en/guide/xml_schema.html#MAV_CMD for information about the
 * structure of the MAV_CMD entries
 */
var MavCmd;
(function (MavCmd) {
    /**
     * Fly a figure eight path as defined by the parameters. Set parameters to NaN/INT32_MAX (as
     * appropriate) to use system-default values. The command is intended for fixed wing vehicles (and VTOL
     * hybrids flying in fixed-wing mode), allowing POI tracking for gimbals that don't support infinite
     * rotation. This command only defines the flight path. Speed should be set independently (use e.g.
     * MAV_CMD_DO_CHANGE_SPEED). Yaw and other degrees of freedom are not specified, and will be
     * flight-stack specific (on vehicles where they can be controlled independent of the heading).
     *
     * @note has location and is destination
     *
     * @param1 Major Radius[m] Major axis radius of the figure eight. Positive: orbit the north circle clockwise. Negative: orbit the north circle counter-clockwise.
          NaN: The radius will be set to 2.5 times the minor radius and direction is clockwise.
          Must be greater or equal to two times the minor radius for feasible values.
     * @param2 Minor Radius[m] Minor axis radius of the figure eight. Defines the radius of the two circles that make up the figure. Negative value has no effect.
          NaN: The radius will be set to the default loiter radius.
     * @param4 Orientation[rad] Orientation of the figure eight major axis with respect to true north (range: [-pi,pi]). NaN: use default orientation aligned to true north.
     * @param5 Latitude/X Center point latitude/X coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle position, or current center if already loitering.
     * @param6 Longitude/Y Center point longitude/Y coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle position, or current center if already loitering.
     * @param7 Altitude/Z Center point altitude MSL/Z coordinate according to MAV_FRAME. If no MAV_FRAME specified, MAV_FRAME_GLOBAL is assumed.
          INT32_MAX or NaN: Use current vehicle altitude.
     */
    MavCmd[MavCmd["DO_FIGURE_EIGHT"] = 35] = "DO_FIGURE_EIGHT";
    /**
     * Request a target system to start an upgrade of one (or all) of its components. For example, the
     * command might be sent to a companion computer to cause it to upgrade a connected flight controller.
     * The system doing the upgrade will report progress using the normal command protocol sequence for a
     * long running operation. Command protocol information: https://mavlink.io/en/services/command.html.
     * @param1 Component ID Component id of the component to be upgraded. If set to 0, all components should be upgraded.
     * @param2 Reboot (min: 0, max: 1, increment: 1) 0: Do not reboot component after the action is executed, 1: Reboot component after the action is executed.
     * @param3 Reserved
     * @param4 Reserved
     * @param5 Reserved
     * @param6 Reserved
     * @param7 WIP: upgrade progress report rate (can be used for more granular control).
     */
    MavCmd[MavCmd["DO_UPGRADE"] = 247] = "DO_UPGRADE";
    /**
     * Command to test groups of related actuators together. This might include groups such as the
     * actuators that contribute to roll, pitch, or yaw torque, actuators that contribute to thrust in x,
     * y, z axis, tilt mechanisms, flaps and spoilers, and so on. This is similar to MAV_CMD_ACTUATOR_TEST,
     * except that multiple actuators may be affected. Different groups may also affect the same actuators
     * (as in the case of controls that affect torque in different axes). Autopilots must NACK this command
     * with MAV_RESULT_TEMPORARILY_REJECTED while armed.
     * @param1 Group Actuator group to check, such as actuators related to roll torque.
     * @param2 Value (min: -1, max: 1) Value to set. This is a normalized value across the full range of the tested group [-1,1].
     */
    MavCmd[MavCmd["ACTUATOR_GROUP_TEST"] = 309] = "ACTUATOR_GROUP_TEST";
    /**
     * Set system and component id. This allows moving of a system and all its components to a new system
     * id, or moving a particular component to a new system/component id. Recipients must reject command
     * addressed to broadcast system ID.
     * @param1 System ID (min: 1, max: 255, increment: 1) New system ID for target component(s). 0: ignore and reject command (broadcast system ID not allowed).
     * @param2 Component ID (min: 0, max: 255, increment: 1) New component ID for target component(s). 0: ignore (component IDs don't change).
     * @param3 Reboot Reboot components after ID change. Any non-zero value triggers the reboot.
     */
    MavCmd[MavCmd["DO_SET_SYS_CMP_ID"] = 610] = "DO_SET_SYS_CMP_ID";
    /**
     * Sets the GNSS coordinates of the vehicle local origin (0,0,0) position. Vehicle should emit
     * GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the
     * local coordinate frame and the global (GNSS) coordinate frame, which may be necessary when (for
     * example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor. This
     * command supersedes SET_GPS_GLOBAL_ORIGIN. Should be sent in a COMMAND_INT (Expected frame is
     * MAV_FRAME_GLOBAL, and this should be assumed when sent in COMMAND_LONG).
     *
     * @note has location
     *
     * @param1 Empty
     * @param2 Empty
     * @param3 Empty
     * @param4 Empty
     * @param5 Latitude Latitude
     * @param6 Longitude Longitude
     * @param7 Altitude[m] Altitude
     */
    MavCmd[MavCmd["DO_SET_GLOBAL_ORIGIN"] = 611] = "DO_SET_GLOBAL_ORIGIN";
    /**
     * Enable Moving Target Indicators (MTI) on streamed video. Support for feature can be checked with
     * CAMERA_CAP_FLAGS_HAS_MTI, and disabled with MAV_CMD_CAMERA_STOP_MTI.
     * @param1 Target Camera ID (min: 0, max: 255, increment: 1) Target camera ID. 7 to 255: MAVLink camera component id. 1 to 6 for cameras attached to the autopilot, which don't have a distinct component id. 0: all cameras. This is used to target specific autopilot-connected cameras. It is also used to target specific cameras when the MAV_CMD is used in a mission.
     */
    MavCmd[MavCmd["CAMERA_START_MTI"] = 2020] = "CAMERA_START_MTI";
    /**
     * Disable Moving Target Indicators (MTI) on streamed video.
     * @param1 Target Camera ID (min: 0, max: 255, increment: 1) Target camera ID. 7 to 255: MAVLink camera component id. 1 to 6 for cameras attached to the autopilot, which don't have a distinct component id. 0: all cameras. This is used to target specific autopilot-connected cameras. It is also used to target specific cameras when the MAV_CMD is used in a mission.
     */
    MavCmd[MavCmd["CAMERA_STOP_MTI"] = 2021] = "CAMERA_STOP_MTI";
    /**
     * Used to manually set/unset emergency status for remote id. This is for compliance with MOC ASTM
     * docs, specifically F358 section 7.7: "Emergency Status Indicator". The requirement can also be
     * satisfied by automatic setting of the emergency status by flight stack, and that approach is
     * preferred. See https://mavlink.io/en/services/opendroneid.html for more information.
     * @param1 Number (min: 0, increment: 1) Set/unset emergency 0: unset, 1: set
     * @param4 Empty
     * @param5 Empty
     * @param5 Empty
     * @param6 Empty
     * @param7 Empty
     */
    MavCmd[MavCmd["ODID_SET_EMERGENCY"] = 12900] = "ODID_SET_EMERGENCY";
    /**
     * Set an external estimate of wind direction and speed. This might be used to provide an initial wind
     * estimate to the estimator (EKF) in the case where the vehicle is wind dead-reckoning, extending the
     * time when operating without GPS before before position drift builds to an unsafe level. For this use
     * case the command might reasonably be sent every few minutes when operating at altitude, and the
     * value is cleared if the estimator resets itself.
     * @param1 Wind speed[m/s] (min: 0) Horizontal wind speed.
     * @param2 Wind speed accuracy[m/s] Estimated 1 sigma accuracy of wind speed. Set to NaN if unknown.
     * @param3 Direction[deg] (min: 0, max: 360) Azimuth (relative to true north) from where the wind is blowing.
     * @param4 Direction accuracy[deg] Estimated 1 sigma accuracy of wind direction. Set to NaN if unknown.
     * @param5 Empty
     * @param6 Empty
     * @param7 Empty
     */
    MavCmd[MavCmd["EXTERNAL_WIND_ESTIMATE"] = 43004] = "EXTERNAL_WIND_ESTIMATE";
    /**
     * Set an external estimate of vehicle attitude. This might be used to provide an initial attitude
     * (especially heading) estimate to the estimator (EKF). Angles are defined in a 3-2-1 (yaw-pitch-roll)
     * intrinsic Tait-Bryan sequence.
     * @param1 Roll[deg] (min: 0, max: 360) Roll angle. Set to NaN if unknown.
     * @param2 Pitch[deg] (min: 0, max: 360) Pitch angle. Set to NaN if unknown.
     * @param3 Yaw[deg] (min: 0, max: 360) Yaw/heading (relative to true north) angle. Set to NaN if unknown.
     * @param4 Tilt accuracy[deg] Estimated 1 sigma accuracy of roll and pitch angles. Set to NaN if unknown.
     * @param5 Empty
     * @param6 Empty
     * @param7 Yaw accuracy[deg] Estimated 1 sigma accuracy of yaw angle. Set to NaN if unknown.
     */
    MavCmd[MavCmd["EXTERNAL_ATTITUDE_ESTIMATE"] = 620] = "EXTERNAL_ATTITUDE_ESTIMATE";
    /**
     * Request GCS control of a system (or of a specific component in a system). A controlled system should
     * only accept MAVLink commands and command-like messages that are sent by its controlling GCS, or from
     * other components with the same system id. Commands from other systems should be rejected with
     * MAV_RESULT_FAILED (except for this command, which may be acknowledged with MAV_RESULT_ACCEPTED if
     * control is granted). Command-like messages should be ignored (or rejected if that is supported by
     * their associated protocol). GCS control of the whole system is managed via a single component that
     * we will refer to here as the "system manager component". This component streams the CONTROL_STATUS
     * message and sets the GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER flag. Other components in the system
     * should monitor for the CONTROL_STATUS message with this flag, and set their controlling GCS to match
     * its published system id. A GCS that wants to control the system should also monitor for the same
     * message and flag, and address the MAV_CMD_REQUEST_OPERATOR_CONTROL to its component id. Note that
     * integrators are required to ensure that there is only one system manager component in the system
     * (i.e. one component emitting the message with GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER set). The
     * MAV_CMD_REQUEST_OPERATOR_CONTROL command is sent by a GCS to the system manager component to request
     * or release control of a system, specifying whether subsequent takeover requests from another GCS are
     * automatically granted, or require permission. The system manager component should grant control to
     * the GCS if the system does not require takeover permission (or is uncontrolled) and ACK the request
     * with MAV_RESULT_ACCEPTED. The system manager component should then stream CONTROL_STATUS indicating
     * its controlling system: all other components with the same system id should monitor this message and
     * set their own controlling GCS to match that of the system manager component. If the system manager
     * component cannot grant control (because takeover requires permission), the request should be
     * rejected with MAV_RESULT_FAILED. The system manager component should then send this same command to
     * the current owning GCS in order to notify of the request. The owning GCS would ACK with
     * MAV_RESULT_ACCEPTED, and might choose to release control of the vehicle, or re-request control with
     * the takeover bit set to allow permission. In case it choses to re-request control with takeover bit
     * set to allow permission, requester GCS will only have 10 seconds to get control, otherwise owning
     * GCS will re-request control with takeover bit set to disallow permission, and requester GCS will
     * need repeat the request if still interested in getting control. Note that the pilots of both GCS
     * should coordinate safe handover offline. Note that in most systems the only controlled component
     * will be the "system manager component", and that will be the autopilot. However separate GCS control
     * of a particular component is also permitted, if supported by the component. In this case the GCS
     * will address MAV_CMD_REQUEST_OPERATOR_CONTROL to the specific component it wants to control. The
     * component will then stream CONTROL_STATUS for its controlling GCS (it must not set
     * GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER). The component should fall back to the system GCS (if any)
     * when it is not directly controlled, and may stop emitting CONTROL_STATUS. The flow is otherwise the
     * same as for requesting control over the whole system.
     * @param1 Sysid requesting control System ID of GCS requesting control. 0 when command sent from GCS to autopilot (autopilot determines requesting GCS sysid from message header). Sysid of GCS requesting control when command sent by autopilot to controlling GCS.
     * @param2 Action 0: Release control, 1: Request control.
     * @param3 Allow takeover Enable automatic granting of ownership on request (by default reject request and notify current owner). 0: Ask current owner and reject request, 1: Allow automatic takeover.
     * @param4 Request timeout[s] (min: 3, max: 60) Timeout in seconds before a request to a GCS to allow takeover is assumed to be rejected. This is used to display the timeout graphically on requester and GCS in control.
     * @param5 Empty
     * @param6 Empty
     * @param7 Empty
     */
    MavCmd[MavCmd["REQUEST_OPERATOR_CONTROL"] = 32100] = "REQUEST_OPERATOR_CONTROL";
})(MavCmd = exports.MavCmd || (exports.MavCmd = {}));
/**
 * CONTROL_STATUS flags.
 */
var GcsControlStatusFlags;
(function (GcsControlStatusFlags) {
    /**
     * If set, this CONTROL_STATUS publishes the controlling GCS for the whole system. If unset, the
     * CONTROL_STATUS indicates the controlling GCS for just the component emitting the message. Note that
     * to request control of the system a GCS should send MAV_CMD_REQUEST_OPERATOR_CONTROL to the component
     * emitting CONTROL_STATUS with this flag set.
     */
    GcsControlStatusFlags[GcsControlStatusFlags["SYSTEM_MANAGER"] = 1] = "SYSTEM_MANAGER";
    /**
     * Takeover allowed (requests for control will be granted). If not set requests for control will be
     * rejected, but the controlling GCS will be notified (and may release control or allow takeover).
     */
    GcsControlStatusFlags[GcsControlStatusFlags["TAKEOVER_ALLOWED"] = 2] = "TAKEOVER_ALLOWED";
})(GcsControlStatusFlags = exports.GcsControlStatusFlags || (exports.GcsControlStatusFlags = {}));
/**
 * These flags indicate the sensor reporting capabilities for TARGET_ABSOLUTE.
 */
var TargetAbsoluteSensorCapabilityFlags;
(function (TargetAbsoluteSensorCapabilityFlags) {
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["POSITION"] = 1] = "POSITION";
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["VELOCITY"] = 2] = "VELOCITY";
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["ACCELERATION"] = 4] = "ACCELERATION";
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["ATTITUDE"] = 8] = "ATTITUDE";
    TargetAbsoluteSensorCapabilityFlags[TargetAbsoluteSensorCapabilityFlags["RATES"] = 16] = "RATES";
})(TargetAbsoluteSensorCapabilityFlags = exports.TargetAbsoluteSensorCapabilityFlags || (exports.TargetAbsoluteSensorCapabilityFlags = {}));
/**
 * The frame of a target observation from an onboard sensor.
 */
var TargetObsFrame;
(function (TargetObsFrame) {
    /**
     * NED local tangent frame (x: North, y: East, z: Down) with origin fixed relative to earth.
     */
    TargetObsFrame[TargetObsFrame["LOCAL_NED"] = 0] = "LOCAL_NED";
    /**
     * FRD local frame aligned to the vehicle's attitude (x: Forward, y: Right, z: Down) with an origin
     * that travels with vehicle.
     */
    TargetObsFrame[TargetObsFrame["BODY_FRD"] = 1] = "BODY_FRD";
    /**
     * NED local tangent frame (x: North, y: East, z: Down) with an origin that travels with vehicle.
     */
    TargetObsFrame[TargetObsFrame["LOCAL_OFFSET_NED"] = 2] = "LOCAL_OFFSET_NED";
    /**
     * Other sensor frame for target observations neither in local NED nor in body FRD.
     */
    TargetObsFrame[TargetObsFrame["OTHER"] = 3] = "OTHER";
})(TargetObsFrame = exports.TargetObsFrame || (exports.TargetObsFrame = {}));
/**
 * RADIO_RC_CHANNELS flags (bitmask).
 */
var RadioRcChannelsFlags;
(function (RadioRcChannelsFlags) {
    /**
     * Failsafe is active. The content of the RC channels data in the RADIO_RC_CHANNELS message is
     * implementation dependent.
     */
    RadioRcChannelsFlags[RadioRcChannelsFlags["FAILSAFE"] = 1] = "FAILSAFE";
    /**
     * Channel data may be out of date. This is set when the receiver is unable to validate incoming data
     * from the transmitter and has therefore resent the last valid data it received.
     */
    RadioRcChannelsFlags[RadioRcChannelsFlags["OUTDATED"] = 2] = "OUTDATED";
})(RadioRcChannelsFlags = exports.RadioRcChannelsFlags || (exports.RadioRcChannelsFlags = {}));
/**
 * Flags indicating errors in a GPS receiver.
 */
var GpsSystemErrorFlags;
(function (GpsSystemErrorFlags) {
    /**
     * There are problems with incoming correction streams.
     */
    GpsSystemErrorFlags[GpsSystemErrorFlags["INCOMING_CORRECTIONS"] = 1] = "INCOMING_CORRECTIONS";
    /**
     * There are problems with the configuration.
     */
    GpsSystemErrorFlags[GpsSystemErrorFlags["CONFIGURATION"] = 2] = "CONFIGURATION";
    /**
     * There are problems with the software on the GPS receiver.
     */
    GpsSystemErrorFlags[GpsSystemErrorFlags["SOFTWARE"] = 4] = "SOFTWARE";
    /**
     * There are problems with an antenna connected to the GPS receiver.
     */
    GpsSystemErrorFlags[GpsSystemErrorFlags["ANTENNA"] = 8] = "ANTENNA";
    /**
     * There are problems handling all incoming events.
     */
    GpsSystemErrorFlags[GpsSystemErrorFlags["EVENT_CONGESTION"] = 16] = "EVENT_CONGESTION";
    /**
     * The GPS receiver CPU is overloaded.
     */
    GpsSystemErrorFlags[GpsSystemErrorFlags["CPU_OVERLOAD"] = 32] = "CPU_OVERLOAD";
    /**
     * The GPS receiver is experiencing output congestion.
     */
    GpsSystemErrorFlags[GpsSystemErrorFlags["OUTPUT_CONGESTION"] = 64] = "OUTPUT_CONGESTION";
})(GpsSystemErrorFlags = exports.GpsSystemErrorFlags || (exports.GpsSystemErrorFlags = {}));
/**
 * Signal authentication state in a GPS receiver.
 */
var GpsAuthenticationState;
(function (GpsAuthenticationState) {
    /**
     * The GPS receiver does not provide GPS signal authentication info.
     */
    GpsAuthenticationState[GpsAuthenticationState["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * The GPS receiver is initializing signal authentication.
     */
    GpsAuthenticationState[GpsAuthenticationState["INITIALIZING"] = 1] = "INITIALIZING";
    /**
     * The GPS receiver encountered an error while initializing signal authentication.
     */
    GpsAuthenticationState[GpsAuthenticationState["ERROR"] = 2] = "ERROR";
    /**
     * The GPS receiver has correctly authenticated all signals.
     */
    GpsAuthenticationState[GpsAuthenticationState["OK"] = 3] = "OK";
    /**
     * GPS signal authentication is disabled on the receiver.
     */
    GpsAuthenticationState[GpsAuthenticationState["DISABLED"] = 4] = "DISABLED";
})(GpsAuthenticationState = exports.GpsAuthenticationState || (exports.GpsAuthenticationState = {}));
/**
 * Signal jamming state in a GPS receiver.
 */
var GpsJammingState;
(function (GpsJammingState) {
    /**
     * The GPS receiver does not provide GPS signal jamming info.
     */
    GpsJammingState[GpsJammingState["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * The GPS receiver detected no signal jamming.
     */
    GpsJammingState[GpsJammingState["OK"] = 1] = "OK";
    /**
     * The GPS receiver detected and mitigated signal jamming.
     */
    GpsJammingState[GpsJammingState["MITIGATED"] = 2] = "MITIGATED";
    /**
     * The GPS receiver detected signal jamming.
     */
    GpsJammingState[GpsJammingState["DETECTED"] = 3] = "DETECTED";
})(GpsJammingState = exports.GpsJammingState || (exports.GpsJammingState = {}));
/**
 * Signal spoofing state in a GPS receiver.
 */
var GpsSpoofingState;
(function (GpsSpoofingState) {
    /**
     * The GPS receiver does not provide GPS signal spoofing info.
     */
    GpsSpoofingState[GpsSpoofingState["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * The GPS receiver detected no signal spoofing.
     */
    GpsSpoofingState[GpsSpoofingState["OK"] = 1] = "OK";
    /**
     * The GPS receiver detected and mitigated signal spoofing.
     */
    GpsSpoofingState[GpsSpoofingState["MITIGATED"] = 2] = "MITIGATED";
    /**
     * The GPS receiver detected signal spoofing but still has a fix.
     */
    GpsSpoofingState[GpsSpoofingState["DETECTED"] = 3] = "DETECTED";
})(GpsSpoofingState = exports.GpsSpoofingState || (exports.GpsSpoofingState = {}));
/**
 * State of RAIM processing.
 */
var GpsRaimState;
(function (GpsRaimState) {
    /**
     * RAIM capability is unknown.
     */
    GpsRaimState[GpsRaimState["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * RAIM is disabled.
     */
    GpsRaimState[GpsRaimState["DISABLED"] = 1] = "DISABLED";
    /**
     * RAIM integrity check was successful.
     */
    GpsRaimState[GpsRaimState["OK"] = 2] = "OK";
    /**
     * RAIM integrity check failed.
     */
    GpsRaimState[GpsRaimState["FAILED"] = 3] = "FAILED";
})(GpsRaimState = exports.GpsRaimState || (exports.GpsRaimState = {}));
/**
 * Actuator groups to test in MAV_CMD_ACTUATOR_GROUP_TEST.
 */
var ActuatorTestGroup;
(function (ActuatorTestGroup) {
    /**
     * Actuators that contribute to roll torque.
     */
    ActuatorTestGroup[ActuatorTestGroup["ROLL_TORQUE"] = 0] = "ROLL_TORQUE";
    /**
     * Actuators that contribute to pitch torque.
     */
    ActuatorTestGroup[ActuatorTestGroup["PITCH_TORQUE"] = 1] = "PITCH_TORQUE";
    /**
     * Actuators that contribute to yaw torque.
     */
    ActuatorTestGroup[ActuatorTestGroup["YAW_TORQUE"] = 2] = "YAW_TORQUE";
    /**
     * Actuators that affect collective tilt.
     */
    ActuatorTestGroup[ActuatorTestGroup["COLLECTIVE_TILT"] = 3] = "COLLECTIVE_TILT";
})(ActuatorTestGroup = exports.ActuatorTestGroup || (exports.ActuatorTestGroup = {}));
/**
 * Source for GLOBAL_POSITION measurement or estimate.
 */
var GlobalPositionSrc;
(function (GlobalPositionSrc) {
    /**
     * Source is unknown or not one of the listed types.
     */
    GlobalPositionSrc[GlobalPositionSrc["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Global Navigation Satellite System (e.g.: GPS, Galileo, Glonass, BeiDou).
     */
    GlobalPositionSrc[GlobalPositionSrc["GNSS"] = 1] = "GNSS";
    /**
     * Vision system (e.g.: map matching).
     */
    GlobalPositionSrc[GlobalPositionSrc["VISION"] = 2] = "VISION";
    /**
     * Pseudo-satellite system (performs GNSS-like function, but usually with transceiver beacons).
     */
    GlobalPositionSrc[GlobalPositionSrc["PSEUDOLITES"] = 3] = "PSEUDOLITES";
    /**
     * Terrain referenced navigation.
     */
    GlobalPositionSrc[GlobalPositionSrc["TRN"] = 4] = "TRN";
    /**
     * Magnetic positioning.
     */
    GlobalPositionSrc[GlobalPositionSrc["MAGNETIC"] = 5] = "MAGNETIC";
    /**
     * Estimated position based on various sensors (eg. a Kalman Filter).
     */
    GlobalPositionSrc[GlobalPositionSrc["ESTIMATOR"] = 6] = "ESTIMATOR";
})(GlobalPositionSrc = exports.GlobalPositionSrc || (exports.GlobalPositionSrc = {}));
/**
 * Status flags for GLOBAL_POSITION
 */
var GlobalPositionFlags;
(function (GlobalPositionFlags) {
    /**
     * Unhealthy sensor/estimator.
     */
    GlobalPositionFlags[GlobalPositionFlags["UNHEALTHY"] = 1] = "UNHEALTHY";
    /**
     * True if the data originates from or is consumed by the primary estimator.
     */
    GlobalPositionFlags[GlobalPositionFlags["PRIMARY"] = 2] = "PRIMARY";
})(GlobalPositionFlags = exports.GlobalPositionFlags || (exports.GlobalPositionFlags = {}));
/**
 * Airspeed information from a sensor.
 */
class Airspeed extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.id = 0;
        this.airspeed = 0;
        this.temperature = 0;
        this.rawPress = 0;
        this.flags = AirspeedSensorFlags[Object.keys(AirspeedSensorFlags)[0]];
    }
}
exports.Airspeed = Airspeed;
Airspeed.MSG_ID = 295;
Airspeed.MSG_NAME = 'AIRSPEED';
Airspeed.PAYLOAD_LENGTH = 12;
Airspeed.MAGIC_NUMBER = 234;
Airspeed.FIELDS = [
    new mavlink_1.MavLinkPacketField('airspeed', 'airspeed', 0, false, 4, 'float', 'm/s'),
    new mavlink_1.MavLinkPacketField('raw_press', 'rawPress', 4, false, 4, 'float', 'hPa'),
    new mavlink_1.MavLinkPacketField('temperature', 'temperature', 8, false, 2, 'int16_t', 'cdegC'),
    new mavlink_1.MavLinkPacketField('id', 'id', 10, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('flags', 'flags', 11, false, 1, 'uint8_t', ''),
];
/**
 * Global position measurement or estimate.
 */
class GlobalPosition extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.id = 0;
        this.timeUsec = BigInt(0);
        this.source = GlobalPositionSrc[Object.keys(GlobalPositionSrc)[0]];
        this.flags = GlobalPositionFlags[Object.keys(GlobalPositionFlags)[0]];
        this.lat = 0;
        this.lon = 0;
        this.alt = 0;
        this.altEllipsoid = 0;
        this.eph = 0;
        this.epv = 0;
    }
}
exports.GlobalPosition = GlobalPosition;
GlobalPosition.MSG_ID = 296;
GlobalPosition.MSG_NAME = 'GLOBAL_POSITION';
GlobalPosition.PAYLOAD_LENGTH = 35;
GlobalPosition.MAGIC_NUMBER = 50;
GlobalPosition.FIELDS = [
    new mavlink_1.MavLinkPacketField('time_usec', 'timeUsec', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('lat', 'lat', 8, false, 4, 'int32_t', 'degE7'),
    new mavlink_1.MavLinkPacketField('lon', 'lon', 12, false, 4, 'int32_t', 'degE7'),
    new mavlink_1.MavLinkPacketField('alt', 'alt', 16, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('alt_ellipsoid', 'altEllipsoid', 20, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('eph', 'eph', 24, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('epv', 'epv', 28, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('id', 'id', 32, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('source', 'source', 33, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('flags', 'flags', 34, false, 1, 'uint8_t', ''),
];
/**
 * Battery dynamic information. This should be streamed (nominally at 1Hz). Static/invariant battery
 * information is sent in BATTERY_INFO. Note that smart batteries should set the
 * MAV_BATTERY_STATUS_FLAGS_CAPACITY_RELATIVE_TO_FULL bit to indicate that supplied capacity values are
 * relative to a battery that is known to be full. Power monitors would not set this bit, indicating
 * that capacity_consumed is relative to drone power-on, and that other values are estimated based on
 * the assumption that the battery was full on power-on.
 */
class BatteryStatusV2 extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.id = 0;
        this.temperature = 0;
        this.voltage = 0;
        this.current = 0;
        this.capacityConsumed = 0;
        this.capacityRemaining = 0;
        this.percentRemaining = 0;
        this.statusFlags = MavBatteryStatusFlags[Object.keys(MavBatteryStatusFlags)[0]];
    }
}
exports.BatteryStatusV2 = BatteryStatusV2;
BatteryStatusV2.MSG_ID = 369;
BatteryStatusV2.MSG_NAME = 'BATTERY_STATUS_V2';
BatteryStatusV2.PAYLOAD_LENGTH = 24;
BatteryStatusV2.MAGIC_NUMBER = 151;
BatteryStatusV2.FIELDS = [
    new mavlink_1.MavLinkPacketField('voltage', 'voltage', 0, false, 4, 'float', 'V'),
    new mavlink_1.MavLinkPacketField('current', 'current', 4, false, 4, 'float', 'A'),
    new mavlink_1.MavLinkPacketField('capacity_consumed', 'capacityConsumed', 8, false, 4, 'float', 'Ah'),
    new mavlink_1.MavLinkPacketField('capacity_remaining', 'capacityRemaining', 12, false, 4, 'float', 'Ah'),
    new mavlink_1.MavLinkPacketField('status_flags', 'statusFlags', 16, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('temperature', 'temperature', 20, false, 2, 'int16_t', 'cdegC'),
    new mavlink_1.MavLinkPacketField('id', 'id', 22, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('percent_remaining', 'percentRemaining', 23, false, 1, 'uint8_t', '%'),
];
/**
 * Emitted during mission execution when control reaches MAV_CMD_GROUP_START.
 */
class GroupStart extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.groupId = 0;
        this.missionChecksum = 0;
        this.timeUsec = BigInt(0);
    }
}
exports.GroupStart = GroupStart;
GroupStart.MSG_ID = 414;
GroupStart.MSG_NAME = 'GROUP_START';
GroupStart.PAYLOAD_LENGTH = 16;
GroupStart.MAGIC_NUMBER = 109;
GroupStart.FIELDS = [
    new mavlink_1.MavLinkPacketField('time_usec', 'timeUsec', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('group_id', 'groupId', 8, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('mission_checksum', 'missionChecksum', 12, false, 4, 'uint32_t', ''),
];
/**
 * Emitted during mission execution when control reaches MAV_CMD_GROUP_END.
 */
class GroupEnd extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.groupId = 0;
        this.missionChecksum = 0;
        this.timeUsec = BigInt(0);
    }
}
exports.GroupEnd = GroupEnd;
GroupEnd.MSG_ID = 415;
GroupEnd.MSG_NAME = 'GROUP_END';
GroupEnd.PAYLOAD_LENGTH = 16;
GroupEnd.MAGIC_NUMBER = 161;
GroupEnd.FIELDS = [
    new mavlink_1.MavLinkPacketField('time_usec', 'timeUsec', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('group_id', 'groupId', 8, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('mission_checksum', 'missionChecksum', 12, false, 4, 'uint32_t', ''),
];
/**
 * RC channel outputs from a MAVLink RC receiver for input to a flight controller or other components
 * (allows an RC receiver to connect via MAVLink instead of some other protocol such as PPM-Sum or
 * S.BUS). Note that this is not intended to be an over-the-air format, and does not replace
 * RC_CHANNELS and similar messages reported by the flight controller. The target_system field should
 * normally be set to the system id of the system to control, typically the flight controller. The
 * target_component field can normally be set to 0, so that all components of the system can receive
 * the message. The channels array field can publish up to 32 channels; the number of channel items
 * used in the array is specified in the count field. The time_last_update_ms field contains the
 * timestamp of the last received valid channels data in the receiver's time domain. The count field
 * indicates the first index of the channel array that is not used for channel data (this and later
 * indexes are zero-filled). The RADIO_RC_CHANNELS_FLAGS_OUTDATED flag is set by the receiver if the
 * channels data is not up-to-date (for example, if new data from the transmitter could not be
 * validated so the last valid data is resent). The RADIO_RC_CHANNELS_FLAGS_FAILSAFE failsafe flag is
 * set by the receiver if the receiver's failsafe condition is met (implementation dependent, e.g.,
 * connection to the RC radio is lost). In this case time_last_update_ms still contains the timestamp
 * of the last valid channels data, but the content of the channels data is not defined by the protocol
 * (it is up to the implementation of the receiver). For instance, the channels data could contain
 * failsafe values configured in the receiver; the default is to carry the last valid data. Note: The
 * RC channels fields are extensions to ensure that they are located at the end of the serialized
 * payload and subject to MAVLink's trailing-zero trimming.
 */
class RadioRcChannels extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.targetSystem = 0;
        this.targetComponent = 0;
        this.timeLastUpdateMs = 0;
        this.flags = RadioRcChannelsFlags[Object.keys(RadioRcChannelsFlags)[0]];
        this.count = 0;
        this.channels = [];
    }
}
exports.RadioRcChannels = RadioRcChannels;
RadioRcChannels.MSG_ID = 420;
RadioRcChannels.MSG_NAME = 'RADIO_RC_CHANNELS';
RadioRcChannels.PAYLOAD_LENGTH = 73;
RadioRcChannels.MAGIC_NUMBER = 20;
RadioRcChannels.FIELDS = [
    new mavlink_1.MavLinkPacketField('time_last_update_ms', 'timeLastUpdateMs', 0, false, 4, 'uint32_t', 'ms'),
    new mavlink_1.MavLinkPacketField('flags', 'flags', 4, false, 2, 'uint16_t', ''),
    new mavlink_1.MavLinkPacketField('target_system', 'targetSystem', 6, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('target_component', 'targetComponent', 7, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('count', 'count', 8, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('channels', 'channels', 9, true, 2, 'int16_t[]', '', 32),
];
/**
 * Information about key components of GNSS receivers, like signal authentication, interference and
 * system errors.
 */
class GnssIntegrity extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.id = 0;
        this.systemErrors = GpsSystemErrorFlags[Object.keys(GpsSystemErrorFlags)[0]];
        this.authenticationState = GpsAuthenticationState[Object.keys(GpsAuthenticationState)[0]];
        this.jammingState = GpsJammingState[Object.keys(GpsJammingState)[0]];
        this.spoofingState = GpsSpoofingState[Object.keys(GpsSpoofingState)[0]];
        this.raimState = GpsRaimState[Object.keys(GpsRaimState)[0]];
        this.raimHfom = 0;
        this.raimVfom = 0;
        this.correctionsQuality = 0;
        this.systemStatusSummary = 0;
        this.gnssSignalQuality = 0;
        this.postProcessingQuality = 0;
    }
}
exports.GnssIntegrity = GnssIntegrity;
GnssIntegrity.MSG_ID = 441;
GnssIntegrity.MSG_NAME = 'GNSS_INTEGRITY';
GnssIntegrity.PAYLOAD_LENGTH = 17;
GnssIntegrity.MAGIC_NUMBER = 169;
GnssIntegrity.FIELDS = [
    new mavlink_1.MavLinkPacketField('system_errors', 'systemErrors', 0, false, 4, 'uint32_t', ''),
    new mavlink_1.MavLinkPacketField('raim_hfom', 'raimHfom', 4, false, 2, 'uint16_t', 'cm'),
    new mavlink_1.MavLinkPacketField('raim_vfom', 'raimVfom', 6, false, 2, 'uint16_t', 'cm'),
    new mavlink_1.MavLinkPacketField('id', 'id', 8, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('authentication_state', 'authenticationState', 9, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('jamming_state', 'jammingState', 10, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('spoofing_state', 'spoofingState', 11, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('raim_state', 'raimState', 12, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('corrections_quality', 'correctionsQuality', 13, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('system_status_summary', 'systemStatusSummary', 14, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('gnss_signal_quality', 'gnssSignalQuality', 15, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('post_processing_quality', 'postProcessingQuality', 16, false, 1, 'uint8_t', ''),
];
/**
 * Current motion information from sensors on a target
 */
class TargetAbsolute extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.timestamp = BigInt(0);
        this.id = 0;
        this.sensorCapabilities = TargetAbsoluteSensorCapabilityFlags[Object.keys(TargetAbsoluteSensorCapabilityFlags)[0]];
        this.lat = 0;
        this.lon = 0;
        this.alt = 0;
        this.vel = [];
        this.acc = [];
        this.qTarget = [];
        this.rates = [];
        this.positionStd = [];
        this.velStd = [];
        this.accStd = [];
    }
}
exports.TargetAbsolute = TargetAbsolute;
TargetAbsolute.MSG_ID = 510;
TargetAbsolute.MSG_NAME = 'TARGET_ABSOLUTE';
TargetAbsolute.PAYLOAD_LENGTH = 106;
TargetAbsolute.MAGIC_NUMBER = 245;
TargetAbsolute.FIELDS = [
    new mavlink_1.MavLinkPacketField('timestamp', 'timestamp', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('lat', 'lat', 8, false, 4, 'int32_t', 'degE7'),
    new mavlink_1.MavLinkPacketField('lon', 'lon', 12, false, 4, 'int32_t', 'degE7'),
    new mavlink_1.MavLinkPacketField('alt', 'alt', 16, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('vel', 'vel', 20, false, 4, 'float[]', 'm/s', 3),
    new mavlink_1.MavLinkPacketField('acc', 'acc', 32, false, 4, 'float[]', 'm/s/s', 3),
    new mavlink_1.MavLinkPacketField('q_target', 'qTarget', 44, false, 4, 'float[]', '', 4),
    new mavlink_1.MavLinkPacketField('rates', 'rates', 60, false, 4, 'float[]', 'rad/s', 3),
    new mavlink_1.MavLinkPacketField('position_std', 'positionStd', 72, false, 4, 'float[]', 'm', 2),
    new mavlink_1.MavLinkPacketField('vel_std', 'velStd', 80, false, 4, 'float[]', 'm/s', 3),
    new mavlink_1.MavLinkPacketField('acc_std', 'accStd', 92, false, 4, 'float[]', 'm/s/s', 3),
    new mavlink_1.MavLinkPacketField('id', 'id', 104, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('sensor_capabilities', 'sensorCapabilities', 105, false, 1, 'uint8_t', ''),
];
/**
 * The location of a target measured by MAV's onboard sensors.
 */
class TargetRelative extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.timestamp = BigInt(0);
        this.id = 0;
        this.frame = TargetObsFrame[Object.keys(TargetObsFrame)[0]];
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.posStd = [];
        this.yawStd = 0;
        this.qTarget = [];
        this.qSensor = [];
        this.type = common_1.LandingTargetType[Object.keys(common_1.LandingTargetType)[0]];
    }
}
exports.TargetRelative = TargetRelative;
TargetRelative.MSG_ID = 511;
TargetRelative.MSG_NAME = 'TARGET_RELATIVE';
TargetRelative.PAYLOAD_LENGTH = 71;
TargetRelative.MAGIC_NUMBER = 28;
TargetRelative.FIELDS = [
    new mavlink_1.MavLinkPacketField('timestamp', 'timestamp', 0, false, 8, 'uint64_t', 'us'),
    new mavlink_1.MavLinkPacketField('x', 'x', 8, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('y', 'y', 12, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('z', 'z', 16, false, 4, 'float', 'm'),
    new mavlink_1.MavLinkPacketField('pos_std', 'posStd', 20, false, 4, 'float[]', 'm', 3),
    new mavlink_1.MavLinkPacketField('yaw_std', 'yawStd', 32, false, 4, 'float', 'rad'),
    new mavlink_1.MavLinkPacketField('q_target', 'qTarget', 36, false, 4, 'float[]', '', 4),
    new mavlink_1.MavLinkPacketField('q_sensor', 'qSensor', 52, false, 4, 'float[]', '', 4),
    new mavlink_1.MavLinkPacketField('id', 'id', 68, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('frame', 'frame', 69, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('type', 'type', 70, false, 1, 'uint8_t', ''),
];
/**
 * Information about GCS in control of this MAV. This should be broadcast at low rate (nominally 1 Hz)
 * and emitted when ownership or takeover status change. Control over MAV is requested using
 * MAV_CMD_REQUEST_OPERATOR_CONTROL.
 */
class ControlStatus extends mavlink_1.MavLinkData {
    constructor() {
        super();
        this.sysidInControl = 0;
        this.flags = GcsControlStatusFlags[Object.keys(GcsControlStatusFlags)[0]];
    }
}
exports.ControlStatus = ControlStatus;
ControlStatus.MSG_ID = 512;
ControlStatus.MSG_NAME = 'CONTROL_STATUS';
ControlStatus.PAYLOAD_LENGTH = 2;
ControlStatus.MAGIC_NUMBER = 184;
ControlStatus.FIELDS = [
    new mavlink_1.MavLinkPacketField('sysid_in_control', 'sysidInControl', 0, false, 1, 'uint8_t', ''),
    new mavlink_1.MavLinkPacketField('flags', 'flags', 1, false, 1, 'uint8_t', ''),
];
const common_2 = require("./common");
/**
 * Fly a figure eight path as defined by the parameters. Set parameters to NaN/INT32_MAX (as
 * appropriate) to use system-default values. The command is intended for fixed wing vehicles (and VTOL
 * hybrids flying in fixed-wing mode), allowing POI tracking for gimbals that don't support infinite
 * rotation. This command only defines the flight path. Speed should be set independently (use e.g.
 * MAV_CMD_DO_CHANGE_SPEED). Yaw and other degrees of freedom are not specified, and will be
 * flight-stack specific (on vehicles where they can be controlled independent of the heading).
 *
 * This command has location.
 * This command is destination.
 */
class DoFigureEightCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.DO_FIGURE_EIGHT;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Major axis radius of the figure eight. Positive: orbit the north circle clockwise. Negative: orbit
     * the north circle counter-clockwise. NaN: The radius will be set to 2.5 times the minor radius and
     * direction is clockwise. Must be greater or equal to two times the minor radius for feasible values.
     *
     * @units m
     */
    get majorRadius() {
        return this._param1;
    }
    set majorRadius(value) {
        this._param1 = value;
    }
    /**
     * Minor axis radius of the figure eight. Defines the radius of the two circles that make up the
     * figure. Negative value has no effect. NaN: The radius will be set to the default loiter radius.
     *
     * @units m
     */
    get minorRadius() {
        return this._param2;
    }
    set minorRadius(value) {
        this._param2 = value;
    }
    /**
     * Orientation of the figure eight major axis with respect to true north (range: [-pi,pi]). NaN: use
     * default orientation aligned to true north.
     *
     * @units rad
     */
    get orientation() {
        return this._param4;
    }
    set orientation(value) {
        this._param4 = value;
    }
    /**
     * Center point latitude/X coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle position, or current center if
     * already loitering.
     */
    get latitude() {
        return this._param5;
    }
    set latitude(value) {
        this._param5 = value;
    }
    /**
     * Center point longitude/Y coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle position, or current center if
     * already loitering.
     */
    get longitude() {
        return this._param6;
    }
    set longitude(value) {
        this._param6 = value;
    }
    /**
     * Center point altitude MSL/Z coordinate according to MAV_FRAME. If no MAV_FRAME specified,
     * MAV_FRAME_GLOBAL is assumed. INT32_MAX or NaN: Use current vehicle altitude.
     */
    get altitude() {
        return this._param7;
    }
    set altitude(value) {
        this._param7 = value;
    }
}
exports.DoFigureEightCommand = DoFigureEightCommand;
/**
 * Request a target system to start an upgrade of one (or all) of its components. For example, the
 * command might be sent to a companion computer to cause it to upgrade a connected flight controller.
 * The system doing the upgrade will report progress using the normal command protocol sequence for a
 * long running operation. Command protocol information: https://mavlink.io/en/services/command.html.
 */
class DoUpgradeCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.DO_UPGRADE;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Component id of the component to be upgraded. If set to 0, all components should be upgraded.
     */
    get componentId() {
        return this._param1;
    }
    set componentId(value) {
        this._param1 = value;
    }
    /**
     * 0: Do not reboot component after the action is executed, 1: Reboot component after the action is
     * executed.
     *
     * @min: 0
     * @max: 1
     * @increment: 1
     */
    get reboot() {
        return this._param2;
    }
    set reboot(value) {
        this._param2 = value;
    }
}
exports.DoUpgradeCommand = DoUpgradeCommand;
/**
 * Command to test groups of related actuators together. This might include groups such as the
 * actuators that contribute to roll, pitch, or yaw torque, actuators that contribute to thrust in x,
 * y, z axis, tilt mechanisms, flaps and spoilers, and so on. This is similar to MAV_CMD_ACTUATOR_TEST,
 * except that multiple actuators may be affected. Different groups may also affect the same actuators
 * (as in the case of controls that affect torque in different axes). Autopilots must NACK this command
 * with MAV_RESULT_TEMPORARILY_REJECTED while armed.
 */
class ActuatorGroupTestCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.ACTUATOR_GROUP_TEST;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Actuator group to check, such as actuators related to roll torque.
     */
    get group() {
        return this._param1;
    }
    set group(value) {
        this._param1 = value;
    }
    /**
     * Value to set. This is a normalized value across the full range of the tested group [-1,1].
     *
     * @min: -1
     * @max: 1
     */
    get value() {
        return this._param2;
    }
    set value(value) {
        this._param2 = value;
    }
}
exports.ActuatorGroupTestCommand = ActuatorGroupTestCommand;
/**
 * Set system and component id. This allows moving of a system and all its components to a new system
 * id, or moving a particular component to a new system/component id. Recipients must reject command
 * addressed to broadcast system ID.
 */
class DoSetSysCmpIdCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.DO_SET_SYS_CMP_ID;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * New system ID for target component(s). 0: ignore and reject command (broadcast system ID not
     * allowed).
     *
     * @min: 1
     * @max: 255
     * @increment: 1
     */
    get systemId() {
        return this._param1;
    }
    set systemId(value) {
        this._param1 = value;
    }
    /**
     * New component ID for target component(s). 0: ignore (component IDs don't change).
     *
     * @min: 0
     * @max: 255
     * @increment: 1
     */
    get componentId() {
        return this._param2;
    }
    set componentId(value) {
        this._param2 = value;
    }
    /**
     * Reboot components after ID change. Any non-zero value triggers the reboot.
     */
    get reboot() {
        return this._param3;
    }
    set reboot(value) {
        this._param3 = value;
    }
}
exports.DoSetSysCmpIdCommand = DoSetSysCmpIdCommand;
/**
 * Sets the GNSS coordinates of the vehicle local origin (0,0,0) position. Vehicle should emit
 * GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the
 * local coordinate frame and the global (GNSS) coordinate frame, which may be necessary when (for
 * example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor. This
 * command supersedes SET_GPS_GLOBAL_ORIGIN. Should be sent in a COMMAND_INT (Expected frame is
 * MAV_FRAME_GLOBAL, and this should be assumed when sent in COMMAND_LONG).
 *
 * This command has location.
 */
class DoSetGlobalOriginCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.DO_SET_GLOBAL_ORIGIN;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Latitude
     */
    get latitude() {
        return this._param5;
    }
    set latitude(value) {
        this._param5 = value;
    }
    /**
     * Longitude
     */
    get longitude() {
        return this._param6;
    }
    set longitude(value) {
        this._param6 = value;
    }
    /**
     * Altitude
     *
     * @units m
     */
    get altitude() {
        return this._param7;
    }
    set altitude(value) {
        this._param7 = value;
    }
}
exports.DoSetGlobalOriginCommand = DoSetGlobalOriginCommand;
/**
 * Enable Moving Target Indicators (MTI) on streamed video. Support for feature can be checked with
 * CAMERA_CAP_FLAGS_HAS_MTI, and disabled with MAV_CMD_CAMERA_STOP_MTI.
 */
class CameraStartMtiCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.CAMERA_START_MTI;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Target camera ID. 7 to 255: MAVLink camera component id. 1 to 6 for cameras attached to the
     * autopilot, which don't have a distinct component id. 0: all cameras. This is used to target specific
     * autopilot-connected cameras. It is also used to target specific cameras when the MAV_CMD is used in
     * a mission.
     *
     * @min: 0
     * @max: 255
     * @increment: 1
     */
    get targetCameraId() {
        return this._param1;
    }
    set targetCameraId(value) {
        this._param1 = value;
    }
}
exports.CameraStartMtiCommand = CameraStartMtiCommand;
/**
 * Disable Moving Target Indicators (MTI) on streamed video.
 */
class CameraStopMtiCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.CAMERA_STOP_MTI;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Target camera ID. 7 to 255: MAVLink camera component id. 1 to 6 for cameras attached to the
     * autopilot, which don't have a distinct component id. 0: all cameras. This is used to target specific
     * autopilot-connected cameras. It is also used to target specific cameras when the MAV_CMD is used in
     * a mission.
     *
     * @min: 0
     * @max: 255
     * @increment: 1
     */
    get targetCameraId() {
        return this._param1;
    }
    set targetCameraId(value) {
        this._param1 = value;
    }
}
exports.CameraStopMtiCommand = CameraStopMtiCommand;
/**
 * Used to manually set/unset emergency status for remote id. This is for compliance with MOC ASTM
 * docs, specifically F358 section 7.7: "Emergency Status Indicator". The requirement can also be
 * satisfied by automatic setting of the emergency status by flight stack, and that approach is
 * preferred. See https://mavlink.io/en/services/opendroneid.html for more information.
 */
class OdidSetEmergencyCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.ODID_SET_EMERGENCY;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Set/unset emergency 0: unset, 1: set
     *
     * @min: 0
     * @increment: 1
     */
    get number() {
        return this._param1;
    }
    set number(value) {
        this._param1 = value;
    }
}
exports.OdidSetEmergencyCommand = OdidSetEmergencyCommand;
/**
 * Set an external estimate of wind direction and speed. This might be used to provide an initial wind
 * estimate to the estimator (EKF) in the case where the vehicle is wind dead-reckoning, extending the
 * time when operating without GPS before before position drift builds to an unsafe level. For this use
 * case the command might reasonably be sent every few minutes when operating at altitude, and the
 * value is cleared if the estimator resets itself.
 */
class ExternalWindEstimateCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.EXTERNAL_WIND_ESTIMATE;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Horizontal wind speed.
     *
     * @units m/s
     * @min: 0
     */
    get windSpeed() {
        return this._param1;
    }
    set windSpeed(value) {
        this._param1 = value;
    }
    /**
     * Estimated 1 sigma accuracy of wind speed. Set to NaN if unknown.
     *
     * @units m/s
     */
    get windSpeedAccuracy() {
        return this._param2;
    }
    set windSpeedAccuracy(value) {
        this._param2 = value;
    }
    /**
     * Azimuth (relative to true north) from where the wind is blowing.
     *
     * @units deg
     * @min: 0
     * @max: 360
     */
    get direction() {
        return this._param3;
    }
    set direction(value) {
        this._param3 = value;
    }
    /**
     * Estimated 1 sigma accuracy of wind direction. Set to NaN if unknown.
     *
     * @units deg
     */
    get directionAccuracy() {
        return this._param4;
    }
    set directionAccuracy(value) {
        this._param4 = value;
    }
}
exports.ExternalWindEstimateCommand = ExternalWindEstimateCommand;
/**
 * Set an external estimate of vehicle attitude. This might be used to provide an initial attitude
 * (especially heading) estimate to the estimator (EKF). Angles are defined in a 3-2-1 (yaw-pitch-roll)
 * intrinsic Tait-Bryan sequence.
 */
class ExternalAttitudeEstimateCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.EXTERNAL_ATTITUDE_ESTIMATE;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * Roll angle. Set to NaN if unknown.
     *
     * @units deg
     * @min: 0
     * @max: 360
     */
    get roll() {
        return this._param1;
    }
    set roll(value) {
        this._param1 = value;
    }
    /**
     * Pitch angle. Set to NaN if unknown.
     *
     * @units deg
     * @min: 0
     * @max: 360
     */
    get pitch() {
        return this._param2;
    }
    set pitch(value) {
        this._param2 = value;
    }
    /**
     * Yaw/heading (relative to true north) angle. Set to NaN if unknown.
     *
     * @units deg
     * @min: 0
     * @max: 360
     */
    get yaw() {
        return this._param3;
    }
    set yaw(value) {
        this._param3 = value;
    }
    /**
     * Estimated 1 sigma accuracy of roll and pitch angles. Set to NaN if unknown.
     *
     * @units deg
     */
    get tiltAccuracy() {
        return this._param4;
    }
    set tiltAccuracy(value) {
        this._param4 = value;
    }
    /**
     * Estimated 1 sigma accuracy of yaw angle. Set to NaN if unknown.
     *
     * @units deg
     */
    get yawAccuracy() {
        return this._param7;
    }
    set yawAccuracy(value) {
        this._param7 = value;
    }
}
exports.ExternalAttitudeEstimateCommand = ExternalAttitudeEstimateCommand;
/**
 * Request GCS control of a system (or of a specific component in a system). A controlled system should
 * only accept MAVLink commands and command-like messages that are sent by its controlling GCS, or from
 * other components with the same system id. Commands from other systems should be rejected with
 * MAV_RESULT_FAILED (except for this command, which may be acknowledged with MAV_RESULT_ACCEPTED if
 * control is granted). Command-like messages should be ignored (or rejected if that is supported by
 * their associated protocol). GCS control of the whole system is managed via a single component that
 * we will refer to here as the "system manager component". This component streams the CONTROL_STATUS
 * message and sets the GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER flag. Other components in the system
 * should monitor for the CONTROL_STATUS message with this flag, and set their controlling GCS to match
 * its published system id. A GCS that wants to control the system should also monitor for the same
 * message and flag, and address the MAV_CMD_REQUEST_OPERATOR_CONTROL to its component id. Note that
 * integrators are required to ensure that there is only one system manager component in the system
 * (i.e. one component emitting the message with GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER set). The
 * MAV_CMD_REQUEST_OPERATOR_CONTROL command is sent by a GCS to the system manager component to request
 * or release control of a system, specifying whether subsequent takeover requests from another GCS are
 * automatically granted, or require permission. The system manager component should grant control to
 * the GCS if the system does not require takeover permission (or is uncontrolled) and ACK the request
 * with MAV_RESULT_ACCEPTED. The system manager component should then stream CONTROL_STATUS indicating
 * its controlling system: all other components with the same system id should monitor this message and
 * set their own controlling GCS to match that of the system manager component. If the system manager
 * component cannot grant control (because takeover requires permission), the request should be
 * rejected with MAV_RESULT_FAILED. The system manager component should then send this same command to
 * the current owning GCS in order to notify of the request. The owning GCS would ACK with
 * MAV_RESULT_ACCEPTED, and might choose to release control of the vehicle, or re-request control with
 * the takeover bit set to allow permission. In case it choses to re-request control with takeover bit
 * set to allow permission, requester GCS will only have 10 seconds to get control, otherwise owning
 * GCS will re-request control with takeover bit set to disallow permission, and requester GCS will
 * need repeat the request if still interested in getting control. Note that the pilots of both GCS
 * should coordinate safe handover offline. Note that in most systems the only controlled component
 * will be the "system manager component", and that will be the autopilot. However separate GCS control
 * of a particular component is also permitted, if supported by the component. In this case the GCS
 * will address MAV_CMD_REQUEST_OPERATOR_CONTROL to the specific component it wants to control. The
 * component will then stream CONTROL_STATUS for its controlling GCS (it must not set
 * GCS_CONTROL_STATUS_FLAGS_SYSTEM_MANAGER). The component should fall back to the system GCS (if any)
 * when it is not directly controlled, and may stop emitting CONTROL_STATUS. The flow is otherwise the
 * same as for requesting control over the whole system.
 */
class RequestOperatorControlCommand extends common_2.CommandLong {
    constructor(targetSystem = 1, targetComponent = 1) {
        super();
        this.command = MavCmd.REQUEST_OPERATOR_CONTROL;
        this.targetSystem = targetSystem;
        this.targetComponent = targetComponent;
    }
    /**
     * System ID of GCS requesting control. 0 when command sent from GCS to autopilot (autopilot determines
     * requesting GCS sysid from message header). Sysid of GCS requesting control when command sent by
     * autopilot to controlling GCS.
     */
    get sysidRequestingControl() {
        return this._param1;
    }
    set sysidRequestingControl(value) {
        this._param1 = value;
    }
    /**
     * 0: Release control, 1: Request control.
     */
    get action() {
        return this._param2;
    }
    set action(value) {
        this._param2 = value;
    }
    /**
     * Enable automatic granting of ownership on request (by default reject request and notify current
     * owner). 0: Ask current owner and reject request, 1: Allow automatic takeover.
     */
    get allowTakeover() {
        return this._param3;
    }
    set allowTakeover(value) {
        this._param3 = value;
    }
    /**
     * Timeout in seconds before a request to a GCS to allow takeover is assumed to be rejected. This is
     * used to display the timeout graphically on requester and GCS in control.
     *
     * @units s
     * @min: 3
     * @max: 60
     */
    get requestTimeout() {
        return this._param4;
    }
    set requestTimeout(value) {
        this._param4 = value;
    }
}
exports.RequestOperatorControlCommand = RequestOperatorControlCommand;
exports.REGISTRY = {
    295: Airspeed,
    296: GlobalPosition,
    369: BatteryStatusV2,
    414: GroupStart,
    415: GroupEnd,
    420: RadioRcChannels,
    441: GnssIntegrity,
    510: TargetAbsolute,
    511: TargetRelative,
    512: ControlStatus,
};
exports.COMMANDS = {
    [MavCmd.DO_FIGURE_EIGHT]: DoFigureEightCommand,
    [MavCmd.DO_UPGRADE]: DoUpgradeCommand,
    [MavCmd.ACTUATOR_GROUP_TEST]: ActuatorGroupTestCommand,
    [MavCmd.DO_SET_SYS_CMP_ID]: DoSetSysCmpIdCommand,
    [MavCmd.DO_SET_GLOBAL_ORIGIN]: DoSetGlobalOriginCommand,
    [MavCmd.CAMERA_START_MTI]: CameraStartMtiCommand,
    [MavCmd.CAMERA_STOP_MTI]: CameraStopMtiCommand,
    [MavCmd.ODID_SET_EMERGENCY]: OdidSetEmergencyCommand,
    [MavCmd.EXTERNAL_WIND_ESTIMATE]: ExternalWindEstimateCommand,
    [MavCmd.EXTERNAL_ATTITUDE_ESTIMATE]: ExternalAttitudeEstimateCommand,
    [MavCmd.REQUEST_OPERATOR_CONTROL]: RequestOperatorControlCommand,
};
//# sourceMappingURL=development.js.map